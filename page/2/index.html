<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>1Stack1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="1Stack1">
<meta property="og:url" content="https://username.github.io/page/2/index.html">
<meta property="og:site_name" content="1Stack1">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="1Stack1">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="1Stack1" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">1Stack1</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://username.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-note/框架/SpringMvc" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E6%A1%86%E6%9E%B6/SpringMvc/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E6%A1%86%E6%9E%B6/SpringMvc/">SpringMvc.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/SpringMvc/image-20230518115006410.png" alt="image-20230518115006410"></p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/SpringMvc/image-20230518115022025.png" alt="image-20230518115022025"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E6%A1%86%E6%9E%B6/SpringMvc/" data-id="cltu174t9000e48nu5u8u7962" data-title="SpringMvc.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/数据库/redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/">reids.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构与数据类型的关系"><a href="#数据结构与数据类型的关系" class="headerlink" title="数据结构与数据类型的关系"></a>数据结构与数据类型的关系</h2><p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230420132049924.png" alt="image-20230420132049924"></p>
<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p><code>Redis自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将其作为默认字符串使用</code></p>
<h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录buf数组中已经使用的字节的数量</span></span><br><span class="line">    <span class="comment">//等于SDS所保存的字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录为sds分配的长度</span></span><br><span class="line">    <span class="type">int</span> alloc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字节数组,用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SDS与C字符转区别"><a href="#SDS与C字符转区别" class="headerlink" title="SDS与C字符转区别"></a>SDS与C字符转区别</h3><ul>
<li><p>常数复杂度获取字符串长度</p>
</li>
<li><p>杜绝缓冲区溢出</p>
</li>
<li><p>减少修改字符串时带来的内存重分配次数</p>
<p><code>通过未使用空间来减少内存重分配次数</code></p>
<p>主要有两种优化策略</p>
<ul>
<li><p>空间预分配</p>
<p><code>当SDS的API对一个SDS进行修改并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间</code></p>
</li>
<li><p>惰性空间释放</p>
<p><code>当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用</code></p>
</li>
</ul>
</li>
<li><p>二进制安全</p>
<p><code>SDS虽然使用&#39;\0&#39;结尾但是由于有len属性，并不会造成二进制安全问题；而C字符串就不能保存像图片、音频、视频这样的二进制数据</code></p>
</li>
<li><p>兼容部分C字符串函数</p>
<p><code>SDS和C字符串一样以&#39;\0&#39;结尾</code></p>
</li>
</ul>
<h3 id="SDS扩容规则"><a href="#SDS扩容规则" class="headerlink" title="SDS扩容规则"></a>SDS扩容规则</h3><ul>
<li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li>
<li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现，除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表。</p>
<h3 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h3><p>节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><code>Redis链表是使用双端链表实现的</code></p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 <code>listNode</code> 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 <code>list</code> 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 <code>NULL</code> ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>哈希表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;<span class="comment">//(size为2^n,计算下标%size可以写为&amp;size-1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>哈希表节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>字典</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;<span class="comment">//保存了需要传递给那些类型特定函数的可选参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//type和privdata属性是针对不同类型的键值对，为创建多态字典而设置的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>Redis使用的哈希算法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 <img src="https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f512c5e9256.png" alt="O(1)">）， 排在其他已有节点的前面。</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0]当前包含的键值对数量 （也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的2^n（<code>2</code> 的 <code>n</code> 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对 rehash 到ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</li>
<li>当ht[0] 包含的所有键值对都迁移到了ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p><code>复制到新表之后由于hashtable的size改变，sizemask改变，hash值可能改变，索引值可能改变</code></p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的，为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p><code>执行渐进式 rehash 的过程中， 字典会同时使用ht[0]和ht[1]两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1]里面， 而ht[0]则不再进行任何添加操作： 这一措施保证了ht[0]包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</code></p>
<h3 id="rehash触发条件"><a href="#rehash触发条件" class="headerlink" title="rehash触发条件"></a>rehash触发条件</h3><p>rehash 的触发条件跟<strong>负载因子（load factor）</strong>有关系。</p>
<p>负载因子可以通过下面这个公式计算：</p>
<p>​			<code>负载因子 = 哈希表已保存节点数量 / 哈希表大小</code></p>
<p>触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li>
</ul>
<h3 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
</ul>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</p>
<p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p>
<h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>跳跃表节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//节点的后退指针 ( backward 属性 ) 用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">//节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    sds ele;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：</span></span><br><span class="line"><span class="comment">    分值相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，</span></span><br><span class="line"><span class="comment">    而成员对象较大的节点则会排在后面(靠近表尾的方向)。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;<span class="comment">//跨度实际上是为了计算这个节点在跳表中的排位。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</span></span><br><span class="line"></span><br><span class="line">    &#125; level[];<span class="comment">//每个跳跃表节点的层高都是1到32之间的随机数</span></span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>跳跃表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="keyword">typedef</span> zskiplistNode *header, *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表中节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419190927089.png" alt="image-20230419190927089"></p>
<h3 id="跳跃表的查询过程"><a href="#跳跃表的查询过程" class="headerlink" title="跳跃表的查询过程"></a>跳跃表的查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<p>举个例子，下图有个 3 层级的跳表。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png" alt="img"></p>
<p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p>
<ul>
<li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li>
<li>但是该层的下一个节点是空节点（ leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li>
<li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li>
<li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li>
</ul>
<h3 id="跳表节点层数的设置"><a href="#跳表节点层数的设置" class="headerlink" title="跳表节点层数的设置"></a>跳表节点层数的设置</h3><h3 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p>举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2802786ab4f52c1e248904e5cef33a74.png" alt="img"></p>
<p>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。</p>
<p>**跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)**。</p>
<p>下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/cdc14698f629c74bf5a239cc8a611aeb.png" alt="img"></p>
<blockquote>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p>
</blockquote>
<p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p>
<p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>参数p设置的小,层数变高的可能性越大，内存占用越大；设置的大，层数变矮的可能性越大，查找效率越低。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<h3 id="为什么不使用平衡树"><a href="#为什么不使用平衡树" class="headerlink" title="为什么不使用平衡树"></a>为什么不使用平衡树</h3><ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
<h3 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 <code>zskiplist</code> 和 <code>zskiplistNode</code> 两个结构组成， 其中 <code>zskiplist</code> 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 <code>zskiplistNode</code> 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code> 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</span></span><br><span class="line"><span class="comment">	如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；</span></span><br><span class="line"><span class="comment">	如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；</span></span><br><span class="line"><span class="comment">	如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code> 数组是整数集合的底层实现： 整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p><strong>升级之后新元素的摆放位置</strong></p>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 <code>0</code> ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 <code>length-1</code> ）。</li>
</ul>
<p><strong>升级示例</strong></p>
<p>举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/5dbdfa7cfbdd1d12a4d9458c6c90d472.png" alt="img"></p>
<p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16&#x3D;80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/e2e3e19fc934e70563fbdfde2af39a2b.png" alt="img"></p>
<p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/e84b052381e240eeb8cc97d6b729968b.png" alt="img"></p>
<p><strong>升级的好处</strong></p>
<ul>
<li><p>提升灵活性</p>
<p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 <code>int16_t</code> 类型的数组来保存 <code>int16_t</code> 类型的值， 只使用 <code>int32_t</code> 类型的数组来保存 <code>int32_t</code> 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
</li>
<li><p>节约内存</p>
<p>当然， 要让一个数组可以同时保存 <code>int16_t</code> 、 <code>int32_t</code> 、 <code>int64_t</code> 三种类型的值， 最简单的做法就是直接使用 <code>int64_t</code> 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 <code>int16_t</code> 类型或者 <code>int32_t</code> 类型的值， 数组都需要使用 <code>int64_t</code> 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 <code>int16_t</code> 类型的值， 那么整数集合的底层实现就会一直是 <code>int16_t</code> 类型的数组， 只有在我们要将<code>int32_t</code> 类型或者 <code>int64_t</code> 类型的值添加到集合时， 程序才会对数组进行升级。</p>
</li>
</ul>
<p><strong>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</strong></p>
<h3 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ul>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<p>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<p>当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p>
<p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的<strong>连续内存块</strong>组成的顺序型（sequential）数据结构。</p>
<h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p>
<p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419190945603.png" alt="image-20230419190945603"></p>
<hr>
<p>表 7-1 压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">长度</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left"><code>4</code> 字节</td>
<td align="left">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 <code>zlend</code> 的位置时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left"><code>4</code> 字节</td>
<td align="left">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left"><code>2</code> 字节</td>
<td align="left">记录了压缩列表包含的节点数量： 当这个属性的值小于 <code>UINT16_MAX</code> （<code>65535</code>）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left">列表节点</td>
<td align="left">不定</td>
<td align="left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>1</code> 字节</td>
<td align="left">特殊值 <code>0xFF</code> （十进制 <code>255</code> ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成， 如图 7-4 所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419190959490.png" alt="image-20230419190959490"></p>
<ul>
<li><code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度：主要是为了实现从后向前遍历。</li>
</ul>
<ul>
<li><p>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>1</code> 字节： 前一节点的长度就保存在这一个字节里面。</p>
</li>
<li><p>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>5</code> 字节：</p>
</li>
</ul>
<ul>
<li><code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度</li>
<li><code>content</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关，如下图（下图中的 content 表示的是实际数据，即本文的 data 字段）：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230420155226789.png" alt="image-20230420155226789"></p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节&#x2F;2字节&#x2F;5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li>
</ul>
<h3 id="压缩列表的连锁更新"><a href="#压缩列表的连锁更新" class="headerlink" title="压缩列表的连锁更新"></a>压缩列表的连锁更新</h3><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>压缩列表除了查找复杂度高的问题，还有一个问题。</p>
<p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<p>前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p>
<ul>
<li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/462c6a65531667f2bcf420953b0aded9.png" alt="img"></p>
<p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p>
<p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/d1a6deff4672580609c99a5b06bf3429.png" alt="img"></p>
<p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p>
<p>多米诺牌的效应就此开始。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/1f0e5ae7ab749078cadda5ba0ed98eac.png" alt="img"></p>
<p>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p>
<p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。</p>
<p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，</p>
<h3 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
<h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><h3 id="设置键的过期时间"><a href="#设置键的过期时间" class="headerlink" title="设置键的过期时间"></a>设置键的过期时间</h3><p>实际上expire,pexpire,expireat三个命令都是使用PEXPIREAT命令实现的</p>
<h3 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，称之为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象</li>
<li>过期字典的值只是一个long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间，是一个毫秒精度的UNIX时间戳</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过期字典</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>

<p>实际上过期字典的键空间的键和数据库键空间的键都指向同一个对象。</p>
<h3 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h3><p>通过过期字典，程序可以通过以下步骤检查一个给定的键是否过期：</p>
<pre><code>* 检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间
* 检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则，未过期。
</code></pre>
<h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><ul>
<li><p>定时删除：设置键的过期时间的同时创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p>
<p><code>定时删除对内存最友好</code></p>
<p><code>但是在过期键比较多的情况下，删除过期键会占用相当一部分CPU时间</code></p>
</li>
<li><p>惰性删除：每次从键空间获取键时，都检查取得的键是否过期，如果过期就删除该键，没有过期，返回改键</p>
<p><code>对CPU时间最友好</code></p>
<p><code>如果一个键已经过期，而这个键仍然保留在数据库中，对内存不友好</code></p>
</li>
<li><p>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。</p>
<p>从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷:</p>
<ul>
<li>定时删除占用太多CPU 时间，影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存，有内存泄漏的危险。</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中:</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的<br>时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的<br>内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率:</p>
<ul>
<li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时<br>删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策<br>略一样，出现浪费内存的情况。</li>
</ul>
<p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p>
</li>
</ul>
<h3 id="redis选择的过期删除策"><a href="#redis选择的过期删除策" class="headerlink" title="redis选择的过期删除策"></a>redis选择的过期删除策</h3><p><strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p>
<blockquote>
<p>Redis 是怎么实现惰性删除的？</p>
</blockquote>
<p>Redis 的惰性删除策略由 db.c 文件中的 <code>expireIfNeeded</code> 函数实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p>
<ul>
<li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 <code>lazyfree_lazy_expire</code> 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li>
<li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端；</li>
</ul>
<blockquote>
<p>Redis 是怎么实现定期删除的？</p>
</blockquote>
<p>定期删除策略的做法：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p>
<p><em>1、这个间隔检查的时间是多长呢？</em></p>
<p>在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p>
<p>特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 进行过期检查。</p>
<p><em>2、随机抽查的数量是多少呢？</em></p>
<p><code>activeExpireCycle</code> 函数中，其中随机抽查的数量是写死在代码中的，数值是 20。</p>
<p>也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。</p>
<p>接下来，详细说说 Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>可以看到，定期删除是一个循环的流程。</p>
<p>那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<blockquote>
<p>定期删除策略简易代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//已过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//随机抽取的数量</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 从过期字典中随机抽取 1 个 key</span></span><br><span class="line">        <span class="comment">//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过时间限制则退出</span></span><br><span class="line">    <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定期删除策略伪代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认每次检查的数据库数量</span></span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line"><span class="comment">#默认每个数据库检查的键数量</span></span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">20</span></span><br><span class="line"><span class="comment">#全局变量，记录检查进度</span></span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">activeExpireCycle</span>():</span><br><span class="line">    <span class="comment">#初始化要检查的数据库数量</span></span><br><span class="line">    <span class="comment">#如果服务器的数据库数量比 DEFAULT_DB_NUMBERS要小</span></span><br><span class="line">    <span class="comment">#那么以服务器的数据库数量为准</span></span><br><span class="line">    <span class="keyword">if</span> server.dbnum ＜ DEFAULT_DB_NUMBERS:</span><br><span class="line">        db_numbers = server.dbnum</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line">    <span class="comment">#遍历各个数据库</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(db_numbers):</span><br><span class="line">        <span class="comment">#如果current_db的值等于服务器的数据库数量</span></span><br><span class="line">        <span class="comment">#这表示检查程序已经遍历了服务器的所有数据库一次</span></span><br><span class="line">        <span class="comment">#将current_db重置为0，开始新的一轮遍历</span></span><br><span class="line">        <span class="keyword">if</span> current_db == server.dbnum:</span><br><span class="line">            current_db = <span class="number">0</span></span><br><span class="line">        <span class="comment">#获取当前要处理的数据库</span></span><br><span class="line">        redisDb = server.db[current_db]</span><br><span class="line">        <span class="comment">#将数据库索引增1，指向下一个要处理的数据库</span></span><br><span class="line">        current_db += <span class="number">1</span></span><br><span class="line">        <span class="comment">#检查数据库键</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_KEY_NUMBERS):</span><br><span class="line">            <span class="comment">#如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span></span><br><span class="line">            <span class="keyword">if</span> redisDb.expires.size() == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#随机获取一个带有过期时间的键</span></span><br><span class="line">            key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line">            <span class="comment">#检查键是否过期，如果过期就删除它</span></span><br><span class="line">            <span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">                delete_key(key_with_ttl)</span><br><span class="line">            <span class="comment">#已达到时间上限，停止处理</span></span><br><span class="line">            <span class="keyword">if</span> reach_time_limit(): </span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" alt="img"></p>
<h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><p>当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。</p>
<h2 id="如何设置-Redis-最大运行内存？"><a href="#如何设置-Redis-最大运行内存？" class="headerlink" title="如何设置 Redis 最大运行内存？"></a>如何设置 Redis 最大运行内存？</h2><p>在配置文件 redis.conf 中，可以通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。 不同位数的操作系统，maxmemory 的默认值是不同的：</p>
<ul>
<li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li>
<li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li>
</ul>
<h2 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h2><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><em>1、不进行数据淘汰的策略</em></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，则会触发 OOM，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p>
<p><em>2、进行数据淘汰的策略</em></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p>
<p>在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ul>
<blockquote>
<p>如何查看当前 Redis 使用的内存淘汰策略？</p>
</blockquote>
<p>可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;noeviction&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，当前 Redis 使用的是 <code>noeviction</code> 类型的内存淘汰策略，它是 Redis 3.0 之后默认使用的内存淘汰策略，表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。</p>
<blockquote>
<p>如何修改 Redis 内存淘汰策略？</p>
</blockquote>
<p>设置内存淘汰策略有两种方法：</p>
<ul>
<li>方式一：通过“<code>config set maxmemory-policy &lt;策略&gt;</code>”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li>
<li>方式二：通过修改 Redis 配置文件修改，设置“<code>maxmemory-policy &lt;策略&gt;</code>”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li>
</ul>
<h2 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h2><blockquote>
<p>什么是 LRU 算法？</p>
</blockquote>
<p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p>
<p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<blockquote>
<p>Redis 是如何实现 LRU 算法的？</p>
</blockquote>
<p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用频繁更新缓存里的元素时，依据LRU算法淘汰的元素不一定是访问最不频繁的元素，反而可能淘汰了较新的元素，出现缓存污染的情况。</p>
<blockquote>
<p>什么是 LFU 算法？</p>
</blockquote>
<p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<blockquote>
<p>Redis 是如何实现 LFU 算法的？</p>
</blockquote>
<p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/lru%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<ul>
<li>ldt 是用来记录 key 的访问时间戳；</li>
<li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li>
</ul>
<p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong>。</p>
<p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p>
<p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p>
<p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p>
<ol>
<li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li>
<li>然后，再按照一定概率增加 logc 的值</li>
</ol>
<p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p>
<ul>
<li><p><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；</p>
</li>
<li><p><code>lfu-log-factor</code> 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.jpg" alt="img"></p>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，不就相当于恢复了缓存数据。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img"></p>
<p>这种保存写操作命令到日志的持久化方式，就是 Redis 里的 <strong>AOF(Append Only File)</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong>，因为没意义。</p>
<p>在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 <code>redis.conf</code> 配置文件中的以下参数：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/0e2d081af084c41802c7b5de8aa41bd4.png" alt="img"></p>
<blockquote>
<p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p>
</blockquote>
<p>第一个好处，<strong>避免额外的检查开销。</strong></p>
<p>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</p>
<p>而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。</p>
<p>第二个好处，<strong>不会阻塞当前写操作命令的执行</strong>，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</p>
<blockquote>
<p>AOF 持久化功能有两个风险。</p>
</blockquote>
<p>第一个风险，执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有<strong>丢失的风险</strong>。</p>
<p>第二个风险，前面说道，由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是<strong>可能会给「下一个」命令带来阻塞风险</strong>。</p>
<p>因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/28afd536c57a46447ddab0a2062abe84.png" alt="img"></p>
<p>如果在将日志内容写入到硬盘时，服务器的硬盘的 I&#x2F;O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行。</p>
<p>认真分析一下，其实这两个风险都有一个共性，都跟「 AOF 日志写回硬盘的时机」有关。</p>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>Redis 写入 AOF 日志的过程，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img"></p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。</p>
<p>在 <code>redis.conf</code> 配置文件中的 <code>appendfsync</code> 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p>这 3 种写回策略都无法能完美解决「主进程阻塞」和「减少数据丢失」的问题，因为两个问题是对立的，偏向于一边的话，就会要牺牲另外一边，原因如下：</p>
<ul>
<li>Always 策略的话，可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；</li>
<li>No 策略的话，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</li>
<li>Everysec 策略的话，是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。</li>
</ul>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/98987d9417b2bab43087f45fc959d32a.png" alt="img"></p>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</p>
<p>如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>举个例子，在没有使用重写机制前，假设前后执行了「set name cehan」和「set name 1Stack1」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p>
<p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name 1Stack1」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p>
<p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p>
<p>然后，在通过 AOF 日志恢复数据时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p>
<p>所以，重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件。</p>
<blockquote>
<p> 为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去？</p>
</blockquote>
<p>因为<strong>如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染</strong>，可能无法用于恢复使用。</p>
<p>所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。</p>
<p>但是在触发 AOF 重写时，比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写，这时是需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。</p>
<p>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。</p>
<p>所以，Redis 的<strong>重写 AOF 过程是由后台子进程 bgrewriteaof来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。</p>
<p>所以，有两个阶段会导致阻塞父进程：</p>
<ul>
<li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li>
<li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li>
</ul>
<p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p>
<p>但是子进程重写过程中，主进程依然可以正常处理命令。</p>
<p>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改的物理内存还是与子进程共享的</strong>。</p>
<p>所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。</p>
<blockquote>
<p>重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
</blockquote>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png" alt="在这里插入图片描述"></p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>
<p>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p>
<p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>
<p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中</p>
<h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。</p>
<p>只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p>
<ul>
<li>900 秒之内，对数据库进行了至少 1 次修改；</li>
<li>300 秒之内，对数据库进行了至少 10 次修改；</li>
<li>60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
<p>RDB文件的<strong>载入</strong>工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在.它就会自动载人RDB文件。</p>
<p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p>
<p>所以可以认为，执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<p>通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</p>
<p>这就是 RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。</p>
<p>因为AOF文件的更新频率通常比RDB文件的更新频率高，所以:</p>
<ul>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
<p>服务器在载人RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h3 id="执行快照时修改数据"><a href="#执行快照时修改数据" class="headerlink" title="执行快照时修改数据"></a>执行快照时修改数据</h3><p>执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，此时主线程可以修改数据使用技术时<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/c34a9d1f58d602ff1fe8601f7270baa7.png" alt="图片"></p>
<p>只有在发生修改内存数据的情况时，物理内存才会被复制一份。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/ebd620db8a1af66fbeb8f4d4ef6adc68.png" alt="图片"></p>
<p>这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。</p>
<p>所以，创建 bgsave 子进程后，由于共享父进程的所有内存数据，于是就可以直接读取主线程（父进程）里的内存数据，并将数据写入到 RDB 文件。</p>
<p>当主线程（父进程）对这些共享的内存数据也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。</p>
<p>但是，如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A&#39;</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A&#39;</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong>。</p>
<p>就是这样，Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。</p>
<p>bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p>
<p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p>
<p>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p>
<p>另外，写时复制的时候会出现这么个极端的情况。</p>
<p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。</p>
<p>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong></p>
<p>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p>
<h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191032659.png" alt="image-20230419191032659"></p>
<p> <code>REDIS</code> 部分， 这个部分的长度为 <code>5</code> 字节， 保存着 <code>&quot;REDIS&quot;</code> 五个字符。 通过这五个字符， 程序可以在载入文件时， 快速检查所载入的文件是否 RDB 文件。</p>
<p><code>db_version</code> 长度为 <code>4</code> 字节， 它的值是一个字符串表示的整数， 这个整数记录了 RDB 文件的版本号， 比如 <code>&quot;0006&quot;</code> 就代表 RDB 文件的版本为第六版。</p>
<p><code>databases</code> 部分包含着零个或任意多个数据库， 以及各个数据库中的键值对数据：</p>
<ul>
<li>如果服务器的数据库状态为空（所有数据库都是空的）， 那么这个部分也为空， 长度为 <code>0</code> 字节。</li>
<li>如果服务器的数据库状态为非空（有至少一个数据库非空）， 那么这个部分也为非空， 根据数据库所保存键值对的数量、类型和内容不同， 这个部分的长度也会有所不同。</li>
</ul>
<p><code>EOF</code> 常量的长度为 <code>1</code> 字节， 这个常量标志着 RDB 文件正文内容的结束， 当读入程序遇到这个值的时候， 它知道所有数据库的所有键值对都已经载入完毕了</p>
<p><code>check_sum</code> 是一个 <code>8</code> 字节长的无符号整数， 保存着一个校验和， 这个校验和是程序通过对 <code>REDIS</code> 、 <code>db_version</code> 、 <code>databases</code> 、 <code>EOF</code> 四个部分的内容进行计算得出的。 服务器在载入 RDB 文件时， 会将载入数据所计算出的校验和与 <code>check_sum</code> 所记录的校验和进行对比， 以此来检查 RDB 文件是否有出错或者损坏的情况出现。</p>
<h4 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h4><p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191043435.png" alt="image-20230419191043435"></p>
<p>每个非空数据库在 RDB 文件中都可以保存为 <code>SELECTDB</code> 、 <code>db_number</code> 、 <code>key_value_pairs</code> 三个部分， 如图 IMAGE_DATABASE_STRUCT_OF_RDB 所示</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191052559.png" alt="image-20230419191052559"></p>
<p><code>SELECTDB</code> 常量的长度为 <code>1</code> 字节， 当读入程序遇到这个值的时候， 它知道接下来要读入的将是一个数据库号码。</p>
<p><code>db_number</code> 保存着一个数据库号码， 根据号码的大小不同， 这个部分的长度可以是 <code>1</code> 字节、 <code>2</code> 字节或者 <code>5</code> 字节。 当程序读入 <code>db_number</code> 部分之后， 服务器会调用 SELECT 命令， 根据读入的数据库号码进行数据库切换， 使得之后读入的键值对可以载入到正确的数据库中。</p>
<p><code>key_value_pairs</code> 部分保存了数据库中的所有键值对数据， 如果键值对带有过期时间， 那么过期时间也会和键值对保存在一起。 根据键值对的数量、类型、内容、以及是否有过期时间等条件的不同， <code>key_value_pairs</code> 部分的长度也会有所不同。</p>
<h5 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h5><p>不带过期时间的键值对在 RDB 文件中对由 <code>TYPE</code> 、 <code>key</code> 、 <code>value</code> 三部分组成， 如图 IMAGE_KEY_WITHOUT_EXPIRE_TIME 所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191059855.png" alt="image-20230419191059855"></p>
<p><code>TYPE</code> 记录了 <code>value</code> 的类型， 长度为 <code>1</code> 字节，当服务器读入 RDB 文件中的键值对数据时， 程序会根据 <code>TYPE</code> 的值来决定如何读入和解释 <code>value</code> 的数据。</p>
<p><code>key</code> 和 <code>value</code> 分别保存了键值对的键对象和值对象：</p>
<ul>
<li>其中 <code>key</code> 总是一个字符串对象， 它的编码方式和 <code>REDIS_RDB_TYPE_STRING</code> 类型的 <code>value</code> 一样。 根据内容长度的不同， <code>key</code> 的长度也会有所不同。</li>
<li>根据 <code>TYPE</code> 类型的不同， 以及保存内容长度的不同， 保存 <code>value</code> 的结构和长度也会有所不同</li>
</ul>
<p>带有过期时间的键值对在 RDB 文件中的结构如图 <code>IMAGE_KEY_WITH_EXPIRE_TIME</code> 所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191109279.png" alt="image-20230419191109279"></p>
<ul>
<li><code>EXPIRETIME_MS</code> 常量的长度为 <code>1</code> 字节， 它告知读入程序， 接下来要读入的将是一个以毫秒为单位的过期时间。</li>
<li><code>ms</code> 是一个 <code>8</code> 字节长的带符号整数， 记录着一个以毫秒为单位的 UNIX 时间戳， 这个时间戳就是键值对的过期时间。</li>
</ul>
<p>value的编码</p>
<ul>
<li><p>字符串对象</p>
<p>字符串对象的编码可以是 <code>REDIS_ENCODING_INT</code> 或者<code>REDIS_ENCODING_RAW</code> 。</p>
<p>如果字符串对象的编码为 <code>REDIS_ENCODING_INT</code> ， 那么说明对象中保存的是长度不超过 <code>32</code> 位的整数。</p>
<p>如果字符串对象的编码为 <code>REDIS_ENCODING_RAW</code> ， 那么说明对象所保存的是一个字符串值， 根据字符串长度的不同， 有压缩和不压缩两种方法来保存这个字符串：</p>
<ul>
<li>如果字符串的长度小于等于 <code>20</code> 字节， 那么这个字符串会直接被原样保存。</li>
<li>如果字符串的长度大于 <code>20</code> 字节， 那么这个字符串会被压缩之后再保存。</li>
</ul>
<p>对于没有被压缩的字符串， RDB 程序会以图 IMAGE_NON_COMPRESS_STRING 所示的结构来保存该字符串。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191117675.png" alt="image-20230419191117675"></p>
<p>其中， <code>string</code> 部分保存了字符串值本身，而 <code>len</code> 保存了字符串值的长度。</p>
<p>对于压缩后的字符串， RDB 程序会以图 IMAGE_COMPRESSED_STRING 所示的结构来保存该字符串。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191127291.png" alt="image-20230419191127291"></p>
<p>其中， <code>REDIS_RDB_ENC_LZF</code> 常量标志着字符串已经被 LZF 算法压缩过了， 读入程序在碰到这个常量时， 会根据之后的 <code>compressed_len</code> 、 <code>origin_len</code> 和 <code>compressed_string</code> 三部分， 对字符串进行解压缩： 其中 <code>compressed_len</code> 记录的是字符串被压缩之后的长度， 而 <code>origin_len</code> 记录的是字符串原来的长度， <code>compressed_string</code> 记录的则是被压缩之后的字符串。</p>
</li>
<li><p>列表对象</p>
<p>如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_LIST</code> ， 那么 <code>value</code> 保存的就是一个 <code>REDIS_ENCODING_LINKEDLIST</code> 编码的列表对象， RDB 文件保存这种对象的结构如图 IMAGE_LINKEDLIST_ENCODING_LIST 所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191138789.png" alt="image-20230419191138789"></p>
</li>
<li><p>集合对象</p>
<p>如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_SET</code> ， 那么 <code>value</code> 保存的就是一个 <code>REDIS_ENCODING_HT</code> 编码的集合对象， RDB 文件保存这种对象的结构如图 IMAGE_HT_ENCODING_SET 所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191146159.png" alt="image-20230419191146159"></p>
</li>
<li><p>哈希表对象</p>
<p>如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_HASH</code> ， 那么 <code>value</code> 保存的就是一个 <code>REDIS_ENCODING_HT</code> 编码的集合对象， RDB 文件保存这种对象的结构如图 IMAGE_HT_HASH 所示：</p>
<ul>
<li><code>hash_size</code> 记录了哈希表的大小， 也即是这个哈希表保存了多少键值对， 读入程序可以通过这个大小知道自己应该读入多少个键值对。</li>
<li>以 <code>key_value_pair</code> 开头的部分代表哈希表中的键值对， 键值对的键和值都是字符串对象， 所以程序会以处理字符串对象的方式来保存和读入键值对。</li>
</ul>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191154715.png" alt="image-20230419191154715"></p>
</li>
<li><p>有序集合对象</p>
<p>如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_ZSET</code> ， 那么 <code>value</code> 保存的就是一个 <code>REDIS_ENCODING_SKIPLIST</code> 编码的有序集合对象， RDB 文件保存这种对象的结构如图 IMAGE_SKIPLIST_ZSET 所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20230419191201586.png" alt="image-20230419191201586"></p>
</li>
<li><p>INTSET 编码的集合</p>
<p>如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_SET_INTSET</code> ， 那么 <code>value</code> 保存的就是一个整数集合对象， RDB 文件保存这种对象的方法是， 先将整数集合转换为字符串对象， 然后将这个字符串对象保存到 RDB 文件里面。</p>
<p>如果程序在读入 RDB 文件的过程中， 碰到由整数集合对象转换成的字符串对象， 那么程序会根据 <code>TYPE</code> 值的指示， 先读入字符串对象， 再将这个字符串对象转换成原来的整数集合对象。</p>
</li>
<li><p>ZIPLIST 编码的列表、哈希表或者有序集合</p>
<p>如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_LIST_ZIPLIST</code> 、 <code>REDIS_RDB_TYPE_HASH_ZIPLIST</code> 或者 <code>REDIS_RDB_TYPE_ZSET_ZIPLIST</code> ， 那么 <code>value</code> 保存的就是一个压缩列表对象， RDB 文件保存这种对象的方法是：</p>
<p>​	 1.将压缩列表转换成一个字符串对象。</p>
<p>​	 2.将转换所得的字符串对象保存到 RDB 文件。</p>
<p>如果程序在读入 RDB 文件的过程中， 碰到由压缩列表对象转换成的字符串对象， 那么程序会根据 <code>TYPE</code> 值的指示， 执行以下操作：</p>
</li>
</ul>
<p>​             1.  读入字符串对象，并将它转换成原来的压缩列表对象。</p>
<p>​			2.根据 <code>TYPE</code> 的值，设置压缩列表对象的类型： 如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_LIST_ZIPLIST</code> ， 那么压缩列表对象的类型为列表； 如果<code>TYPE</code> 的值   </p>
<p>​             为 <code>REDIS_RDB_TYPE_HASH_ZIPLIST</code> ， 那么压缩列表对象的类型为哈希表； 如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_ZSET_ZIPLIST</code> ， 那么压缩列表对象			的类型为有序集合。</p>
<h3 id="RDB-和-AOF-合体"><a href="#RDB-和-AOF-合体" class="headerlink" title="RDB 和 AOF 合体"></a>RDB 和 AOF 合体</h3><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p>
<ul>
<li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li>
<li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li>
</ul>
<blockquote>
<p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p>
</blockquote>
<p>在 Redis 4.0 提出的RDB 和 AOF 合体使用，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p>
<p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p>
<p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/f67379b60d151262753fec3b817b8617.png" alt="图片"></p>
<p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<h1 id="redis生产问题"><a href="#redis生产问题" class="headerlink" title="redis生产问题"></a>redis生产问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><pre><code>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓永远不会生效，这些请求都会打到数据库
</code></pre>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>解决办法：</p>
<ul>
<li><p>缓存空对象<br><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/b3419db09e654dee9d8fd5a8ae584b27.png" alt="在这里插入图片描述"></p>
<pre><code>  优点：实现简单,维护方便
  缺点：额外的内存消耗
       可能造成短期不一致
</code></pre>
</li>
<li><p>布隆过滤<br>  <img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/3319fc471b5744ea99e98754e3ef85d4.png" alt="在这里插入图片描述"></p>
</li>
<li><p>非法请求的限制</p>
<p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p>
</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p>
<p>布隆过滤器会通过 3 个操作完成标记：</p>
<ul>
<li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ul>
<p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/86b0046c2622b2c4bda697f9bc0f5b28.png" alt="图片"></p>
<p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否在数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p>
<p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><pre><code>缓存雪崩是指在同一时间段大量的缓存key同时失效或者redis服务宕机,导致大量请求到达数据库,带来巨大压力
</code></pre>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/953193076aed493aa7ea1745e0180124.png" alt="在这里插入图片描述"></p>
<p>解决方案：</p>
<blockquote>
<p>怎样解决大量数据同时过期</p>
</blockquote>
<p><em>1. 确保数据过期时间不在同一时刻</em></p>
<p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<p><em>2. 互斥锁</em></p>
<p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
<p><em>3. 双 key 策略</em></p>
<p>我们对缓存数据可以使用两个 key，一个是<strong>主 key，会设置过期时间</strong>，一个是<strong>备 key，不会设置过期</strong>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p>
<p>当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，<strong>同时更新「主 key 」和「备 key 」的数据。</strong></p>
<p>双 key 策略的好处是，当主 key 过期了，有大量请求获取缓存数据的时候，直接返回备 key 的数据，这样可以快速响应请求。而不用因为 key 失效而导致大量请求被锁阻塞住（采用了互斥锁，仅一个请求来构建缓存），后续再通知后台线程，重新构建主 key 的数据。</p>
<p><em>4. 后台更新缓存</em></p>
<p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p>
<p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p>
<p>解决上面的问题的方式有两种。</p>
<p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p>
<p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p>
<p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p>
<p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p>
<blockquote>
<p>Redis宕机解决</p>
</blockquote>
<p><em>1. 服务熔断或请求限流机制</em></p>
<p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p>
<p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p>
<p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<p><em>2. 构建 Redis 缓存高可靠集群</em></p>
<p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p>
<p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><pre><code>缓存击穿问题也叫热点key问题,就是一个被高并发访问并且缓存重建业务复杂的key突然失效,
无数的请求访问会在瞬间给数据库带来巨大的冲击
</code></pre>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/6912879d6a3a4cd9b4e0e64109940d32.png" alt="在这里插入图片描述"><br>解决方案：</p>
<ul>
<li>互斥锁<br><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/f781855728ff481f9053d863181b539d.png" alt="在这里插入图片描述"></li>
<li>逻辑过期<br><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/777500b8e1d34568956615d251354388.png" alt="在这里插入图片描述"><br><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/6a1b0f5a264c4d76b470c1ed3966eff0.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><h2 id="数据一致性问题原因"><a href="#数据一致性问题原因" class="headerlink" title="数据一致性问题原因"></a>数据一致性问题原因</h2><p>在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题</p>
<p><strong>出现了数据库和缓存的数据不一致的问题</strong>，是因为<strong>并发问题</strong>！</p>
<ul>
<li><p>先更新数据库，再更新缓存</p>
<p>举个例子，比如「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/8febac10b14bed16cb96d1d944cd08da.png" alt="图片"></p>
<p>A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。</p>
<p>此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p>
</li>
<li><p>先更新缓存，再更新数据库</p>
<p>假设「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/454a8228a6549176ad7e0484fba3c92b.png" alt="图片"></p>
<p>A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1。</p>
<p>此时，数据库中的数据是 1，而缓存中的数据却是 2，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p>
</li>
</ul>
<p>所以，<strong>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象</strong>。</p>
<h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><blockquote>
<p>操作缓存和数据库时有三个问题要考虑：</p>
</blockquote>
<p>1.删除缓存还是更新缓存</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作过多(即应用一直都执行写操作而不执行读操作)</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存(推荐使用)</li>
</ul>
<p>2.如何保证缓存与数据库操作的同时成功或失败</p>
<ul>
<li>单体系统：将缓存与数据库操作放在一个事务</li>
<li>分布式系统：利用TCC等分布式事务方案</li>
</ul>
<p>3.先操作缓存还是先操作数据库</p>
<h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>该策略又可以细分为「读策略」和「写策略」。</p>
<p><strong>写策略的步骤：</strong></p>
<ul>
<li>更新数据库中的数据；</li>
<li>删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<blockquote>
<p>写策略时先更新数据库，还是先删除缓存？</p>
</blockquote>
<ul>
<li><p>先删除缓存，再更新数据库</p>
<p>假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/cc208c2931b4e889d1a58cb655537767.png" alt="图片"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p>
<p>可以看到，<strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong>。</p>
</li>
<li><p>先更新数据库，再删除缓存</p>
<p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/1cc7401143e79383ead96582ac11b615.png" alt="图片"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</p>
</li>
</ul>
<p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p>
<p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p>
<p>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p>
<p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p>
<p>为了确保万无一失，还可以给缓存数据加上了「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p>
<blockquote>
<p>这种操作的问题</p>
</blockquote>
<p>「先更新数据库， 再删除缓存」其实是两个操作，比如<strong>在删除缓存的时候失败了，导致缓存中的数据是旧值</strong>。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2a2ea2854bbc3ae8ae86d7da45fa32ee.png" alt="图片"></p>
<p>解决方案：</p>
<ul>
<li><p>重试机制。</p>
<p>可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<ul>
<li>如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li>
<li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li>
</ul>
<p>举个例子，来说明重试机制的过程。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/a4440f0d572612e0832b903e4a62bd2b.png" alt="图片"></p>
</li>
<li><p>订阅 MySQL binlog，再操作缓存。</p>
<p>「<strong>先更新数据库，再删缓存</strong>」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p>
<p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p>
<p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p>
<p>下图是 Canal 的工作原理：</p>
</li>
</ul>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2ee2280e9f59b6b4879ebdec6eb0cf52.png" alt="图片"></p>
<p>所以，如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删  	除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</p>
<h3 id="Read-Write-Through-Pattern-读写穿透"><a href="#Read-Write-Through-Pattern-读写穿透" class="headerlink" title="Read&#x2F;Write Through Pattern(读写穿透)"></a>Read&#x2F;Write Through Pattern(读写穿透)</h3><p>该模式下服务端把缓存作为主要数据存储,从中读写数据,而由缓存将此数据读取和写入数据库，因此减轻了应用程序的维护和编写，但是我们经常使用的分布式缓存并没有提供这种功能</p>
<p>写操作：<br><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/d1e3ad29fdc74ab6a956a74ecb57ee0c.png" alt="在这里插入图片描述"><br>读操作：<br><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/d214d541100740878a8af150a09fc9f3.png" alt="在这里插入图片描述"></p>
<h3 id="Write-Behind-Pattern-异步缓存写入"><a href="#Write-Behind-Pattern-异步缓存写入" class="headerlink" title="Write Behind Pattern(异步缓存写入)"></a>Write Behind Pattern(异步缓存写入)</h3><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。但是，两个又有很大的不同：Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</p>
<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20240115164836637.png" alt="image-20240115164836637"></p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20240115164913174.png" alt="image-20240115164913174"></p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/image-20240115164952299.png" alt="image-20240115164952299"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" data-id="cltu174t9000h48nu7f9x2qmq" data-title="reids.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/计算机基础/计算机网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote>
<p>什么是HTTP</p>
</blockquote>
<p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h2 id="HTTP头格式"><a href="#HTTP头格式" class="headerlink" title="HTTP头格式"></a>HTTP头格式</h2><p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524195350073.png" alt="image-20230524195350073"></p>
<h2 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h2><p>“1”字头（信息状态）：接收的请求正在处理</p>
<p>“2”字头（表示成功）：200（OK请求成功）、201（Created已创建）、204（No content无内容）、206（ Partial Content只需要其中一部分）</p>
<p>“3”字头（重定向）：301（Move Permanently永久移动 ）、302（Found临时移动）、304（Not Modified未修改——意思是指缓存未过期，不用重新下载，直接使用缓存。同时也能推断出服务器资源未被修改）</p>
<p>“4”字头（客户端错误）：400（Bad Request错误请求&#x2F;语法错误）、401（Unauthorized未认证&#x2F;未验证）、403（Forbidden禁止访问）、404（Not Found未找到——资源已消失&#x2F;网址打错了）、409（Conflict冲突——可能是新旧版本冲突）</p>
<p>“5”字头：（服务器错误）：500（Internet Server Error内部错误）、502（Bad Gateway网关&#x2F;代理错误）、503（Sever Unavailable超载或维护）</p>
<h2 id="Get和Post"><a href="#Get和Post" class="headerlink" title="Get和Post"></a>Get和Post</h2><p><strong>GET 的语义是从服务器获取指定的资源</strong>，GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 。</p>
<p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据。</p>
<blockquote>
<p>请说一下安全和幂等的概念</p>
</blockquote>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<blockquote>
<p>GET 请求可以带 body 吗？</p>
</blockquote>
<p>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><ul>
<li><p><strong>强制缓存</strong>，指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
</li>
<li><p><strong>协商缓存</strong>，协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98etag.png" alt="img"></p>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><blockquote>
<p>HTTP与HTTPS的区别</p>
</blockquote>
<ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<blockquote>
<p>HTTPS解决了那些问题</p>
</blockquote>
<p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容。——–通信使用明文（不加密）</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染。———-无法证明报文的完整性</li>
<li><strong>冒充风险</strong>，比如冒充网站。———不验证通信方的身份</li>
</ul>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，。</li>
<li><strong>身份证书</strong>：证明网站是官网。</li>
</ul>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p>
<blockquote>
<p>HTTPS 是如何解决上面的三个风险的？</p>
</blockquote>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<blockquote>
<p>描述一下混合加密</p>
</blockquote>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="混合加密"></p>
<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<blockquote>
<p>采用「混合加密」的方式的原因：</p>
</blockquote>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<blockquote>
<p>描述一下摘要算法 + 数字签名</p>
</blockquote>
<p>计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png" alt="img"></p>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，有两种流程：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt="img"></p>
<blockquote>
<p>TLS之RSA密钥交换算法握手过程</p>
</blockquote>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tls%E6%8F%A1%E6%89%8B.png" alt="img"></p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/https_rsa.png" alt="img"></p>
<blockquote>
<p>RSA的缺陷</p>
</blockquote>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><blockquote>
<p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上有什么改进</p>
</blockquote>
<ul>
<li><p>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接"></p>
</li>
<li><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为<strong>「队头堵塞」</strong>。（默认不开启）</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="管道网络传输"></p>
</li>
</ul>
<blockquote>
<p> HTTP&#x2F;1.1 还是有性能瓶颈</p>
</blockquote>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，造成队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<blockquote>
<p> HTTP&#x2F;1.1 该如何优化吗？</p>
</blockquote>
<ul>
<li>使用HTTP缓存来尽量避免发送 HTTP 请求</li>
<li>在需要发送 HTTP 请求时，减少请求次数<ul>
<li>减少重定向请求次数</li>
<li>合并请求</li>
<li>延迟发送请求（例如：树形控件的懒加载）</li>
</ul>
</li>
<li>减少服务器的 HTTP 响应的数据大小<ul>
<li>对响应的资源进行<strong>压缩</strong>，包括<strong>有损压缩</strong>和<strong>无损压缩</strong></li>
</ul>
</li>
</ul>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><blockquote>
<p>HTTP&#x2F;2相对于HTTP&#x2F;1.1有什么优化?</p>
</blockquote>
<p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25-HTTP2.png" alt="HTT/1 ~ HTTP/2"></p>
<p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ul>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ul>
<blockquote>
<p>说一下头部压缩</p>
</blockquote>
<p>对于常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，大大提高了编码效率，同时节约了带宽资源。</p>
<p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP&#x2F;2 连接时长或者请求次数。</p>
<blockquote>
<p>解释一下并发传输</p>
</blockquote>
<p>通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240316195337919.png" alt="image-20240316195337919"></p>
<p>客户端和服务器<strong>双方都可以建立 Stream</strong>，因为服务端可以主动推送资源给客户端， 客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<blockquote>
<p>介绍一下服务器主动推送资源</p>
</blockquote>
<p>比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分；在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数，如上图右边部分：</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240316195508650.png" alt="image-20240316195508650"></p>
<p>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240316195119573.png" alt="image-20240316195119573"></p>
<p>如上图，在 Stream 1 中通知客户端 CSS 资源即将到来，然后在 Stream 2 中发送 CSS 资源，注意 Stream 1 和 2 是可以<strong>并发</strong>的。</p>
<blockquote>
<p>HTTP&#x2F;2的缺点</p>
</blockquote>
<ul>
<li>队头阻塞；</li>
<li>TCP 与 TLS 的握手时延迟；</li>
<li>网络迁移需要重新连接；</li>
</ul>
<blockquote>
<p>为什么会队头阻塞</p>
</blockquote>
<p>HTTP&#x2F;2是基于TCP协议， TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524193952443.png" alt="image-20230524193952443"></p>
<blockquote>
<p>什么是网络迁移需要重新连接</p>
</blockquote>
<p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。</p>
<h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524194011145.png" alt="image-20230524194011145"></p>
<blockquote>
<p>QUIC的优点</p>
</blockquote>
<ul>
<li>无队头阻塞；</li>
<li>更快的连接建立；</li>
<li>连接迁移；</li>
</ul>
<blockquote>
<p>QUIC为什么没有对头阻塞</p>
</blockquote>
<p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，但是 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。虽然QUIC 对每个数据包都有一个序号唯一标识，协议会保证数据包的可靠性。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP&#x2F;3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP&#x2F;3。</p>
<p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524194223794.png" alt="image-20230524194223794"></p>
<blockquote>
<p>如何保证连接迁移</p>
</blockquote>
<p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WiFi 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，</p>
<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<blockquote>
<p>HTTP&#x2F;3如何解决动态表问题</p>
</blockquote>
<p><strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。</p>
<p>QUIC 会有两个特殊的单向流：</p>
<ul>
<li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方；</li>
<li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li>
</ul>
<p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><blockquote>
<p>TCP的作用</p>
</blockquote>
<p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<blockquote>
<p>如何唯一的确定一个TCP连接</p>
</blockquote>
<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524200036746.png" alt="image-20230524200036746"></p>
<p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p>
</blockquote>
<p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230436594.png" alt="img"></p>
<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li><p>文件描述符限制</p>
</li>
<li><p>内存限制</p>
</li>
</ul>
<blockquote>
<p>TCP 如何保证传输的可靠性？</p>
</blockquote>
<ol>
<li><strong>根据序列号来实现数据包重新排序以及去重</strong></li>
<li><strong>超时重传</strong> </li>
<li><strong>流量控制</strong> </li>
<li><strong>拥塞控制</strong></li>
</ol>
<h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524195426514.png" alt="image-20230524195426514"></p>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><blockquote>
<p>阐述一下TCP三次握手过程</p>
</blockquote>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
</ul>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230500953.png" alt="第一个报文 —— SYN 报文"></p>
<ul>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
</ul>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230504118.png" alt="第二个报文 —— SYN + ACK 报文"></p>
<ul>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
</ul>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230508297.png" alt="第三个报文 —— ACK 报文"></p>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>。</p>
<blockquote>
<p>为什么使用三次握手</p>
</blockquote>
<p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<blockquote>
<p>为什么两次握手无法防止历史连接建立</p>
</blockquote>
<p><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<blockquote>
<p>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</p>
</blockquote>
<p>主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ul>
<blockquote>
<p>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</p>
</blockquote>
<p><strong>当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」，是非常没有效率的。</p>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<blockquote>
<p>为什么挥手需要四次？</p>
</blockquote>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<blockquote>
<p>为什么 TIME_WAIT 等待的时间是 2MSL？</p>
</blockquote>
<p><code>MSL</code> 是 <strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：如果第四次挥手丢失(也就是主动断开方ACK丢包)，被动断开方重新发送FIN，ACK传输时间+重发FIN传输时间 &lt;&#x3D;2MSL</p>
<blockquote>
<p>为什么需要 TIME_WAIT 状态？</p>
</blockquote>
<ul>
<li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p>
<p>TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
</li>
<li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p>
<p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
</li>
</ul>
<blockquote>
<p>过多的 TIME-WAIT 状态有什么危害</p>
</blockquote>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><blockquote>
<p>TCP重传机制包括哪些？</p>
</blockquote>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK方法</li>
<li>D-SACK</li>
</ul>
<blockquote>
<p>什么是超时重传</p>
</blockquote>
<p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据.</p>
<blockquote>
<p>TCP 会发生超时重传的情况</p>
</blockquote>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p><code>RTT</code> 指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。</p>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</strong></p>
<p><strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>什么是快速重传</p>
</blockquote>
<p><strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<blockquote>
<p>快速重传的问题</p>
</blockquote>
<p><strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p>
<p>假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p>
<blockquote>
<p>什么是SACK方法</p>
</blockquote>
<p>在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.jpg" alt="选择性确认"></p>
<h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p>
<p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25.jpg" alt="窗口探测"></p>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><blockquote>
<p>什么是TCP流量控制</p>
</blockquote>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></p>
<blockquote>
<p>为什么需要流量控制</p>
</blockquote>
<p>双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在发数据的话，接收方只能把收到的数据包丢掉。不仅出现丢包问题还浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><blockquote>
<p>TCP有流量控制了为什么要有拥塞控制？</p>
</blockquote>
<p>计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p><strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<blockquote>
<p>如何知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<blockquote>
<p>什么是慢启动？</p>
</blockquote>
<p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，</p>
<blockquote>
<p>慢启动过程</p>
</blockquote>
<p>慢启动的算法规则：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p>慢启动算法的变化过程如下图：</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/27.jpg" alt="慢启动算法"></p>
<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<blockquote>
<p> 什么是拥塞避免算法</p>
</blockquote>
<p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p>
<p>规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p>
<p>假定 <code>ssthresh</code> 为 <code>8</code>：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
<p>拥塞避免算法的变化过程如下图：</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/28.jpg" alt="拥塞避免"></p>
<p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<blockquote>
<p>什么是拥塞发生算法</p>
</blockquote>
<p>在拥塞避免算法中就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<blockquote>
<p>发生超时重传的拥塞发生算法</p>
</blockquote>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/29.jpg" alt="拥塞发送 —— 超时重传"></p>
<blockquote>
<p>发生快速重传的拥塞发生算法</p>
</blockquote>
<p> <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<blockquote>
<p>快速恢复算法</p>
</blockquote>
<p>快速重传和快速恢复算法一般同时使用，</p>
<p>进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p>快速恢复算法的变化过程如下图：</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png" alt="快速重传和快速恢复"></p>
<h2 id="TCP-快速建立连接"><a href="#TCP-快速建立连接" class="headerlink" title="TCP 快速建立连接"></a>TCP 快速建立连接</h2><p>由于第三次握手是可以携带数据的，但是在下一次（不是同个 TCP 连接的下一次）发起 HTTP GET 请求时，经历的 RTT 也是一样</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/44.jpg" alt="常规 HTTP 请求"></p>
<p>在 Linux 3.7 内核版本中，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-Wireshark/45.jpg" alt="常规 HTTP 请求 与 Fast  Open HTTP 请求"></p>
<h2 id="优化TCP"><a href="#优化TCP" class="headerlink" title="优化TCP"></a>优化TCP</h2><h3 id="三次握手优化"><a href="#三次握手优化" class="headerlink" title="三次握手优化"></a>三次握手优化</h3><blockquote>
<p>客户端的优化</p>
</blockquote>
<p>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传的次数。</p>
<blockquote>
<p>服务端的优化</p>
</blockquote>
<p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以调整 SYN 半连接队列的大小。</p>
<p>如果遭受 SYN 攻击，在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</p>
<p>在全连接队列满了还可以用 RST 通知客户端连接建立失败。</p>
<p>如果 accpet 队列溢出严重，可以提高队列大小。</p>
<blockquote>
<p>什么是syncookies ？</p>
</blockquote>
<p>syncookies 的工作原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.jpg" alt="开启 syncookies 功能"></p>
<blockquote>
<p>绕过三次握手</p>
</blockquote>
<p>TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，同时必须保证服务端和客户端同时支持。</p>
<h3 id="四次挥手优化"><a href="#四次挥手优化" class="headerlink" title="四次挥手优化"></a>四次挥手优化</h3><blockquote>
<p>主动方的优化</p>
</blockquote>
<p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文。</p>
<p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，可以设置最大数量，超过时连接也会直接释放。</p>
<p>当 TIME_WAIT 状态过多时，可以将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p>
<blockquote>
<p>被动方的优化</p>
</blockquote>
<p>在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p>
<p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，就会重发 FIN 报文。</p>
<h3 id="数据传输优化"><a href="#数据传输优化" class="headerlink" title="数据传输优化"></a>数据传输优化</h3><p>TCP 可靠性是通过 ACK 确认报文实现的，又依赖滑动窗口提升了发送速度也兼顾了接收方的处理能力。</p>
<p>可以提升滑动窗口的上限来提升发送速度必须。</p>
<h2 id="面向字节流协议"><a href="#面向字节流协议" class="headerlink" title="面向字节流协议"></a>面向字节流协议</h2><blockquote>
<p>为什么 UDP 是面向报文的协议？</p>
</blockquote>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，再组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<blockquote>
<p>为什么 TCP 是面向字节流的协议？</p>
</blockquote>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p>
<blockquote>
<p>为什么TCP会有粘包现象</p>
</blockquote>
<p>当发送方发送多个小数据包时，由于TCP协议的流量控制和拥塞控制机制，可能会将这些不满足MSS的数据包合并为一个大的TCP分段进行传输，或者将超过MSS的数据包强行拆分。—–&gt;Nagle算法</p>
<p>接收方由于用户进程不及时接收数据，从而导致粘包现象。下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p>
<blockquote>
<p>如何解决粘包？</p>
</blockquote>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<ul>
<li>固定长度的消息；——-&gt; 不常使用</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。—–&gt;比如：自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大，当接收方接收到包头的大小后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</li>
</ul>
<h2 id="TCP序列号"><a href="#TCP序列号" class="headerlink" title="TCP序列号"></a>TCP序列号</h2><blockquote>
<p>为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？</p>
</blockquote>
<p>主要原因是为了防止历史报文被下一个相同四元组的连接接收。</p>
<blockquote>
<p>序列号最大为4G，如果发生回绕怎么办？</p>
</blockquote>
<p>TCP 头部会使用时间戳选项，要求连接双方维护最近一次收到的数据包的时间戳，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<blockquote>
<p>序列号是如何变化的？</p>
</blockquote>
<ul>
<li><strong>序列号（用来解决乱序问题） &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>确认号（用来解决丢包问题） &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<blockquote>
<p>什么是确认号？</p>
</blockquote>
<p>指下一次「期望」收到的数据的序列号发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<p>UDP头格式</p>
</blockquote>
<p><img src="/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524201251619.png" alt="image-20230524201251619"></p>
<blockquote>
<p>为什么UDP有报文长度字段</p>
</blockquote>
<p>虽然IP层记录了消息长度，但IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，这时就需要报文长度字段来确定消息长度。</p>
<h2 id="TCP与UDP对比"><a href="#TCP与UDP对比" class="headerlink" title="TCP与UDP对比"></a>TCP与UDP对比</h2><blockquote>
<p>TCP 和 UDP 区别：</p>
</blockquote>
<p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<blockquote>
<p>TCP 和 UDP 应用场景</p>
</blockquote>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p> 由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p>
</blockquote>
<p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<h2 id="端口使用"><a href="#端口使用" class="headerlink" title="端口使用"></a>端口使用</h2><blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>可以的。</p>
<p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，互不影响。</p>
<blockquote>
<p>多个 TCP 服务进程可以同时绑定同一个端口吗？</p>
</blockquote>
<p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。</p>
<blockquote>
<p>客户端的端口可以重复使用吗？</p>
</blockquote>
<p>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。</p>
<p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="cltu174ta000j48nu4dra7rqi" data-title="计算机网络.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/数据库/mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="读操作过程"><a href="#读操作过程" class="headerlink" title="读操作过程"></a>读操作过程</h1><p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。</li>
</ul>
<blockquote>
<p>执行一条 SQL 查询语句，期间发生了什么？</p>
</blockquote>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份(基于TCP协议传输)；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h1 id="写操作过程"><a href="#写操作过程" class="headerlink" title="写操作过程"></a>写操作过程</h1><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p>
<p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;1Stack&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交，进行「两阶段提交」。</li>
</ol>
<h1 id="记录的存储"><a href="#记录的存储" class="headerlink" title="记录的存储"></a>记录的存储</h1><h2 id="数据存储的文件"><a href="#数据存储的文件" class="headerlink" title="数据存储的文件"></a>数据存储的文件</h2><p>MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。</p>
<p>下面时InnoDB的存储</p>
<blockquote>
<p> MySQL 数据库的文件存放在哪个目录？</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> datadir       <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p> 每创建一个 database（数据库） 都会在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p>
<p>比如，下面有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/database.png" alt="img"></p>
<p>然后，进入 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;my_test 目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@1Stack1 ~]#ls /var/lib/mysql/my_test</span><br><span class="line">db.opt  </span><br><span class="line">t_order.frm  </span><br><span class="line">t_order.ibd</span><br></pre></td></tr></table></figure>

<p>可以看到，共有三个文件，这三个文件分别代表着：</p>
<ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li>
</ul>
<p>数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。</p>
<h2 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h2><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<ul>
<li>行（row）</li>
</ul>
<p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<ul>
<li>页（page）</li>
</ul>
<p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p>
<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的.</p>
<ul>
<li>区（extent）</li>
</ul>
<p>InnoDB 存储引擎是用 B+ 树来组织数据的,B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。这时让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p>
<ul>
<li><p>4、段（segment）</p>
<p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，事务隔离就是 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
</li>
</ul>
<h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p>数据页包括七个部分，结构如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/243b1466779a9e107ae3ef0155604a17.png" alt="图片"></p>
<p>这 7 个部分的作用如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/fabd6dadd61a0aa342d7107213955a72.png" alt="图片"></p>
<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/557d17e05ce90f18591c2305871af665.png" alt="图片"></p>
<p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p>
<p>数据页的主要作用是存储记录，也就是数据库的数据。</p>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>。</p>
<p>数据页中有一个<strong>页目录</strong>，起到记录的索引作用，为了能快速找到记录。</p>
<blockquote>
<p>InnoDB 是如何给记录创建页目录的呢</p>
</blockquote>
<p>页目录与记录的关系如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p>
<p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li>
</ol>
<p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p>
<p>以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，查找主键为 11 的用户记录：</p>
<ul>
<li>先二分得出槽中间位是 (0+4)&#x2F;2&#x3D;2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li>
<li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)&#x2F;2&#x3D; 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li>
</ul>
<blockquote>
<p>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？</p>
</blockquote>
<p>比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。</p>
<p>解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为想要查找的内容。</p>
<blockquote>
<p>如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p>
</blockquote>
<p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ul>
<h3 id="B-Tree与数据页"><a href="#B-Tree与数据页" class="headerlink" title="B+Tree与数据页"></a>B+Tree与数据页</h3><p>因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p>
<blockquote>
<p>当需要存储大量的记录时，就需要多个数据页，这时就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p>
</blockquote>
<p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。</p>
<p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p>
<p>通过上图，看出 B+ 树的特点：</p>
<ul>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<p>看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p>
<ul>
<li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li>
<li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li>
<li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li>
</ul>
<p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p>
<h2 id="InnoDB-行格式"><a href="#InnoDB-行格式" class="headerlink" title="InnoDB 行格式"></a>InnoDB 行格式</h2><p>行格式（row_format），就是一条记录的存储结构。</p>
<p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p>
<ul>
<li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li>
<li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li>
<li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li>
</ul>
<p>下面都是基于 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。</p>
<blockquote>
<p>COMPACT 行格式长什么样？</p>
</blockquote>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/COMPACT.drawio.png" alt="img"></p>
<p>可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p>
<h3 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h3><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p>
<h4 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h4><p>char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p>
<p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p>
<p>下面这张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure>

<p>现在 t_user 表里有这三条记录：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/t_test.png" alt="img"></p>
<p>接下来， 看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。</p>
<p>先来看第一条记录：</p>
<ul>
<li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li>
<li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li>
<li>age 列和 id 列不是变长字段，所以这里不用管。</li>
</ul>
<p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>，所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png" alt="img"></p>
<p>同样的道理， 也可以得出<strong>第二条记录</strong>的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A82.png" alt="img"></p>
<p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A83.png" alt="img"></p>
<blockquote>
<p>为什么「变长字段长度列表」的信息要按照逆序存放？</p>
</blockquote>
<p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p>
<p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p>
<p>同样的道理， NULL 值列表的信息也需要逆序存放。</p>
<blockquote>
<p>每个数据库表的行格式都有「变长字段字节数列表」吗？</p>
</blockquote>
<p>其实变长字段字节数列表不是必须的。</p>
<p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p>
<p>所以「变长字段长度列表」只出现在数据表有变长字段的时候。</p>
<h4 id="2-NULL-值列表"><a href="#2-NULL-值列表" class="headerlink" title="2. NULL 值列表"></a>2. NULL 值列表</h4><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p>
<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li>
</ul>
<p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p>
<p>还是以 t_user 表的这三条记录作为例子：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/t_test.png" alt="img"></p>
<p>下面是这三条记录的行格式中的 NULL 值列表是怎样存储的。</p>
<p>先来看<strong>第一条记录</strong>，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是这样的：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/null%E5%80%BC%E5%88%97%E8%A1%A81.png" alt="img"></p>
<p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/null%E5%80%BC%E5%88%97%E8%A1%A82.png" alt="img"></p>
<p>所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。</p>
<p>接下来看<strong>第二条记录</strong>，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/null%E5%80%BC%E5%88%97%E8%A1%A83.png" alt="img"></p>
<p>最后<strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/null%E5%80%BC%E5%88%97%E8%A1%A84.png" alt="img"></p>
<p> 把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/null%E5%80%BC%E5%88%97%E8%A1%A85.png" alt="img"></p>
<blockquote>
<p>每个数据库表的行格式都有「NULL 值列表」吗？</p>
</blockquote>
<p>NULL 值列表也不是必须的。</p>
<p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p>
<p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p>
<blockquote>
<p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p>
</blockquote>
<p>「NULL 值列表」的空间不是固定 1 字节的。</p>
<p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p>
<h4 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3.记录头信息"></a>3.记录头信息</h4><p>记录头信息中包含的内容很多，下面是几个比较重要的：</p>
<ul>
<li>delete_mask ：标识此条数据是否被删除。从这里可以知道，执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>
<h3 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h3><p>记录真实数据部分除了自定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png" alt="img"></p>
<ul>
<li>row_id</li>
</ul>
<p>如果建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
<ul>
<li>trx_id</li>
</ul>
<p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
<ul>
<li>roll_pointer</li>
</ul>
<p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p>
<h2 id="varchar-n-中-n-最大取值"><a href="#varchar-n-中-n-最大取值" class="headerlink" title="varchar(n) 中 n 最大取值"></a>varchar(n) 中 n 最大取值</h2><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p>
<p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节。</p>
<p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小。要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p>
<h3 id="单字段的情况"><a href="#单字段的情况" class="headerlink" title="单字段的情况"></a>单字段的情况</h3><p>一行记录最大只能存储 65535 字节的数据。那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？</p>
<p>定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test ( </span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">65535</span>)  <span class="keyword">NULL</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure>

<p>看能不能成功创建一张表：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/error.png" alt="img"></p>
<p>可以看到，创建失败了。</p>
<p>从报错信息就可以知道<strong>一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead</strong>。</p>
<blockquote>
<p>这个 storage overhead 是什么呢？</p>
</blockquote>
<p>其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说<strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以，  在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p>
<p>这是因为存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p>
<ul>
<li>真实数据</li>
<li>真实数据占用的字节数</li>
<li>NULL 标识，如果不允许为NULL，这部分不需要</li>
</ul>
<blockquote>
<p>本次案例中，「NULL 值列表」所占用的字节数是多少？</p>
</blockquote>
<p>前面创建表的时候，字段是允许为 NULL 的，所以<strong>会用 1 字节来表示「NULL 值列表」</strong>。</p>
<blockquote>
<p>本次案例中，「变长字段长度列表」所占用的字节数是多少？</p>
</blockquote>
<p>「变长字段长度列表」所占用的字节数 &#x3D; 所有「变长字段长度」占用的字节数之和。</p>
<p>所以，要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：</p>
<ul>
<li>条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；</li>
<li>条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</li>
</ul>
<p>这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。</p>
<p><strong>因为这个案例是只有 1 个变长字段，所以「变长字段长度列表」&#x3D; 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p>
<p>因为在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p>
<p>先来测试看看 varchar(65533) 是否可行？</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/65533.png" alt="img"></p>
<p>可以看到，还是不行，接下来看看 varchar(65532) 是否可行？</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/65532.png" alt="img"></p>
<p>可以看到，创建成功了。说明推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。</p>
<p>当然，上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：</p>
<ul>
<li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li>
</ul>
<p>上面所说的只是针对于一个字段的计算方式。</p>
<h3 id="多字段的情况"><a href="#多字段的情况" class="headerlink" title="多字段的情况"></a>多字段的情况</h3><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</strong>。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></p>
<h2 id="行溢出后，MySQL-是怎么处理的？"><a href="#行溢出后，MySQL-是怎么处理的？" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h2><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p>
<p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="img"></p>
<p>上面这个是 Compact 行格式在发生行溢出后的处理。</p>
<p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p>
<p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png" alt="img"></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p>
<p>所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎。</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>可以按照四个角度来分类索引。</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p>
<p>每一种存储引擎支持的索引类型不一定相同，表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p>
<p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li>
</ul>
<p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p>
<blockquote>
<p>B+Tree索引是怎么实现的</p>
</blockquote>
<p>先创建一张商品表，id 为主键，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `product`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `product_no` <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>

<p>商品表里，有这些行数据：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/824c43b801c64e81acb0a9b042d50311.png" alt="img"></p>
<p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</p>
<p>主键索引的 B+Tree 如图所示</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/image-20230422203033133.png" alt="image-20230422203033133"></p>
<h4 id="通过主键查询商品数据的过程"><a href="#通过主键查询商品数据的过程" class="headerlink" title="通过主键查询商品数据的过程"></a>通过主键查询商品数据的过程</h4><p>比如， 执行了下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id<span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：</p>
<ul>
<li>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；</li>
<li>在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</li>
<li>在叶子节点的索引数据（4，5，6）中进行查找，然后找到了索引值为 5 的行数据。</li>
</ul>
<p>数据库的索引和数据都是存储在硬盘的，把读取一个节点当作一次磁盘 I&#x2F;O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I&#x2F;O 操作。</p>
<p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p>
<h4 id="通过二级索引查询商品数据的过程"><a href="#通过二级索引查询商品数据的过程" class="headerlink" title="通过二级索引查询商品数据的过程"></a>通过二级索引查询商品数据的过程</h4><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p>
<ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>这里将前面的商品表中的 product_no （商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/image-20230422203720178.png" alt="image-20230422203720178"></p>
<p>其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。</p>
<p>如果用 product_no 二级索引查询商品，如下查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/image-20230422204151945.png" alt="image-20230422204151945"></p>
<p>不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据</strong>。</p>
<blockquote>
<p>二级索引与数据页</p>
</blockquote>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p>
<h4 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h4><h5 id="B-Tree与其他数据结构对比"><a href="#B-Tree与其他数据结构对比" class="headerlink" title="B+Tree与其他数据结构对比"></a>B+Tree与其他数据结构对比</h5><p><em><strong>1、B+Tree vs B Tree</strong></em></p>
<p>B+树的叶子节点只存储数据，非叶子节点只存储索引信息，因此单个节点可以存储更多的索引信息，而数据量相对较少。相比之下，B树的非叶子节点也存储了数据，所以单个节点的数据量较大。在进行查询时，需要读取节点的节点数量就越多，因此相同I&#x2F;O次数下，可以查询更多的节点。</p>
<p>下面是 3 阶的 B 树的查询过程</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/341cedca6863fcd0624febd835165ae2.gif" alt="图片"></p>
<p>假设在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：</p>
<ol>
<li>与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；</li>
<li>然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；</li>
<li>走到索引为9的节点，然后找到了索引值 9 的节点。</li>
</ol>
<p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p>
<p><em><strong>2、B+Tree vs 二叉树</strong></em></p>
<p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p>
<p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p>
<p><em><strong>3、B+Tree vs Hash</strong></em></p>
<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
<h5 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h5><ul>
<li><p>1、单点查询</p>
<p>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。</p>
<p>但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。</p>
<p><strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少</strong>。</p>
</li>
<li><p>2、插入和删除效率</p>
<p>B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快，</p>
<p>比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/25508b0cd9c44ef6937fdd737020a7f1.gif" alt="请添加图片描述"></p>
</li>
</ul>
<p>​	下面这个动图是删除 B 树 0008 节点的过程，可能会导致树的复杂变化：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2be62679487640bbaac663fa96c7f35f.gif" alt="请添加图片描述"></p>
<p>​	甚至，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 B+ 树	根节点的过程：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/23730b5af987480fabff0f1d142a2b6c.gif" alt="请添加图片描述"></p>
<p>​	B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如	下面这个动图是删除 B 树根节点的过程：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/7552002f9b8195ab650d431bfe66cce2.gif" alt="图片"></p>
<p>​	B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且B+树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。</p>
<p>​	因此，<strong>B+ 树的插入和删除效率更高</strong>。</p>
<ul>
<li><p>3、范围查询</p>
<p>B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p>
<p>因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>，比如说想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。</p>
<p>而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</p>
<p>因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。</p>
</li>
</ul>
<h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p>虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：</p>
<ul>
<li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；</li>
<li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；</li>
</ul>
<h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p>
<p>这两个区别在前面也提到了：</p>
<ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p>
<p>在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p>
<h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p>
<p>在创建表时，创建主键索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p>
<p>在创建表时，创建唯一索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure>

<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p>
<p>在创建表时，创建普通索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>建表后，如果要创建普通索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure>

<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
<p>在创建表时，创建前缀索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure>

<h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p>
<ul>
<li>建立在单列上的索引称为单列索引，比如主键索引；</li>
<li>建立在多列上的索引称为联合索引；</li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p>
<p>比如，将商品表中的 product_no 和 name 字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure>

<p>联合索引<code>(product_no, name)</code> 的 B+Tree 示意图如下。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/image-20230422204749791.png" alt="image-20230422204749791"></p>
<p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p>
<p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p>
<p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p> 这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/image-20230422205036495.png" alt="image-20230422205036495"></p>
<p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行<code>where b = 2</code>这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的 key 是有序的</strong>。</p>
<p>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行<code>where a = 2 and b = 7</code>是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。</p>
<h5 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h5><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p>
<p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
<blockquote>
<p>范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？</p>
</blockquote>
<p>接下来，举例几个范围查例子。</p>
<p>Q1: <code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p>
<p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a &gt; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a &gt; 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a &gt; 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p>
<p><strong>但是在符合 a &gt; 1 条件的二级索引记录的范围里，b 字段的值是无序的</strong>。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a &gt; 1 查询条件，而 b 字段的值是无序的：</p>
<ul>
<li>a 字段值为 5 的记录，该记录的 b 字段值为 8；</li>
<li>a 字段值为 6 的记录，该记录的 b 字段值为 10；</li>
<li>a 字段值为 7 的记录，该记录的 b 字段值为 5；</li>
</ul>
<p>因此， 不能根据查询条件 b &#x3D; 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。</p>
<p>所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a &gt; 1，与 b &#x3D; 2 无关。</p>
<p>因此，<strong>Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p>
<p> 也可以在执行计划中的 key_len 知道这一点，在使用联合索引进行查询的时候，通过 key_len  可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条件。</p>
<p>举例个例子 ，a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q1 这条查询语句执行计划如下，可以看到 key_len 为 4 字节（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节），说明只有 a 字段用到了联合索引进行索引查询，而且可以看到，即使 b 字段没用到联合索引，key 为 idx_a_b，说明 Q1 查询语句使用了 idx_a_b 联合索引。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/q1.png" alt="img"></p>
<p>通过 Q1 查询语句 可以知道，a 字段使用了 &gt; 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ &gt;）后就停止匹配了，因此 b 字段并没有使用到联合索引。</p>
<p>Q2: <code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p>
<p>Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。</p>
<p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 &gt;&#x3D; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 &gt;&#x3D; 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a&gt;&#x3D; 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p>
<p>虽然在符合 a&gt;&#x3D; 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a &#x3D; 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong>（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。</p>
<p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b &#x3D; 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a &#x3D; 1 and b &#x3D; 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。</p>
<p>所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<p> 也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/q2.png" alt="img"></p>
<p>通过 Q2 查询语句 可以知道，虽然 a 字段使用了 &gt;&#x3D; 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ &gt;&#x3D;）后就停止匹配了，b 字段还是可以用到了联合索引的。</p>
<p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p>
<p>Q3 查询条件中 <code>a BETWEEN 2 AND 8</code> 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN … AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 &gt;&#x3D; and &#x3D;&lt;。而有的数据库则不包含 value1 和 value2 边界值（类似于 &gt; and &lt;）。</p>
<p> 也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/q3.png" alt="img"></p>
<p>通过 Q3 查询语句 可以知道，虽然 a 字段使用了 BETWEEN 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ BETWEEN）后就停止匹配了，b 字段还是可以用到了联合索引的。</p>
<p>Q4: <code>SELECT * FROM t_user WHERE name like &#39;j%&#39; and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p>
<p>由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。</p>
<p>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是[‘j’,’k’)。注意， j 是闭区间。如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/q4-1.drawio.png" alt="img"></p>
<p>虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，<strong>但是对于符合 name &#x3D; j 的二级索引记录的范围里，age字段的值是「有序」的</strong>（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。</p>
<p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age &#x3D; 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 <code>name = &#39;j&#39; and age = 22</code> 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/q4-2.drawio.png" alt="img"></p>
<p>所以，<strong>Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<p> 也可以在执行计划中的 key_len 知道这一点。本次例子中：</p>
<ul>
<li><p>name 字段的类型是 varchar(30) 且不为 NULL，数据库表使用了 utf8mb4 字符集，一个字符集为 utf8mb4 的字符是 4 个字节，因此 name 字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为 name 是变长类型的字段，需要再加 2 字节（用于存储该字段实际数据的长度值），也就是 name 的 key_len 为 122。</p>
<p>key_len 的显示比较特殊，行格式是由 innodb存 储引擎实现的，而执行计划是在server 层生成的，所以它不会去问 innodb 存储引擎可变字段的长度占用多少字节，而是不管三七二十一都使用 2 字节表示可变字段的长度。</p>
<p>毕竟 key_len 的目的只是为了告诉 索引查询中用了哪些索引字段，而不是为了准确告诉这个字段占用多少字节空间。</p>
<p>Q4 查询语句的执行计划如下，可以看到 key_len 为 126 字节，name 的 key_len 为 122，age 的 key_len 为 4，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 name 和 age 字段都用到了联合索引进行索引查询。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/q4-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p>
</li>
<li><p>age 字段的类型是 int 且不为 NULL，key_len 为 4。</p>
</li>
</ul>
<p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面 也用了四个例子说明了</strong>。</p>
<h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><blockquote>
<p>对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p>
</blockquote>
<ul>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
<p>当查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p>
<h5 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h5><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p>
<p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%8C%BA%E5%88%86%E5%BA%A6.png" alt="区分度计算公式"></p>
<p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p>
<p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p>
<h5 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h5><p>针对针对下面这条 SQL，怎么通过索引来提高查询效率呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<p>更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p>
<p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p>
<p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。</p>
<h2 id="什么时候需要-不需要创建索引？"><a href="#什么时候需要-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul>
<li>需要占用物理空间，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li>
</ul>
<p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p>
<h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为 都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul>
<li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>这里说一下几种常见优化索引的方法：</p>
<ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效；</li>
</ul>
<h3 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h3><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助 减小索引项的大小。</p>
<p>不过，前缀索引有一定的局限性，例如：</p>
<ul>
<li><p>order by 就无法使用前缀索引；</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前缀索引之所以不能使用ORDER BY，是因为在使用前缀索引时，MySQL只会对索引中的前缀进行查询，而不会对整个索引进行扫描。如果使用ORDER BY，则需要对索引中的所有数据进行排序，而前缀索引只包含部分数据，无法提供完整的排序数据。因此，如果需要使用ORDER BY，则需要使用完整索引。</span><br></pre></td></tr></table></figure>
</li>
<li><p>无法把前缀索引用作覆盖索引；</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">覆盖索引，是指可以直接从索引中读取全部数据，无需回表。但是比如建立联合索引时，就无法完成用作覆盖索引</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>
<p>假设 只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p>
<p>可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p>
<p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作。</p>
<h3 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h3><blockquote>
<p>在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？</p>
</blockquote>
<p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p>
<p><strong>如果使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p>
<p><strong>如果 使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面， 通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p>
<p>举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%A1%B5%E5%88%86%E8%A3%82.png" alt="img"></p>
<p>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p>
<p>而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%BC%80%E8%BE%9F%E6%96%B0%E9%A1%B5.png" alt="img"></p>
<p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。</p>
<p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p>
<h3 id="索引最好设置为-NOT-NULL"><a href="#索引最好设置为-NOT-NULL" class="headerlink" title="索引最好设置为 NOT NULL"></a>索引最好设置为 NOT NULL</h3><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p>
<ul>
<li><p>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p>
</li>
<li><p>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行空间中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>，如下图的紫色部分：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/COMPACT.drawio.png" alt="img"></p>
</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>用上了索引并不意味着查询的时候会使用到索引，所以 心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。</p>
<p>这里简单说一下，发生索引失效的情况：</p>
<ul>
<li><p>当 使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</p>
</li>
<li><p>当 在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</p>
</li>
<li><p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</p>
</li>
<li><p>在 WHERE 子句中，使用or中有非索引字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对于两个索引列，MYSQL可以理解为把这个语句拆成了两条语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `comment` <span class="keyword">WHERE</span> `toconuid` <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `comment` <span class="keyword">WHERE</span> `tocomuid` <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mysql中or和in的效率问题"><a href="#mysql中or和in的效率问题" class="headerlink" title="mysql中or和in的效率问题"></a>mysql中or和in的效率问题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#低效: </span><br><span class="line"><span class="keyword">select</span>…. <span class="keyword">from</span> location <span class="keyword">where</span> loc_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> loc_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> loc_id <span class="operator">=</span> <span class="number">30</span> </span><br><span class="line">#高效 </span><br><span class="line"><span class="keyword">select</span>… <span class="keyword">from</span> location <span class="keyword">where</span> loc_in  <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>in或or在字段有添加索引的情况下，查询很快，两者查询速度没有什么区别；</li>
<li>in或or在字段没有添加索引的情况下,所连接的字段越多(1or2or3or4or……)，or比in的查询效率低很多，or的效率为O(n)，而in的效率为O(logn)</li>
</ol>
<blockquote>
<p>为何推荐在没有索引的情况下使用in呢？</p>
</blockquote>
<ul>
<li>OR，就是从a1匹配，匹配失败，去匹配a2，直到匹配成功或者一个都匹配不上，时间复杂度O(n)</li>
<li>IN，先将a1, a2, …, an变成二叉树，通过二叉树查找，时间复杂度O(log n)</li>
</ul>
<h3 id="根据执行计划判断索引"><a href="#根据执行计划判断索引" class="headerlink" title="根据执行计划判断索引"></a>根据执行计划判断索引</h3><p>如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/798ab1331d1d6dff026e262e788f1a28.png" alt="img"></p>
<p>对于执行计划，参数有：</p>
<ul>
<li>possible_keys 字段表示可能用到的索引；</li>
<li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li>
<li>key_len 表示索引的长度；</li>
<li>rows 表示扫描的数据行数。</li>
<li>type 表示数据扫描类型， 需要重点看这个。</li>
</ul>
<p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p>
<ul>
<li>All（全表扫描）；</li>
<li>index（全索引扫描）；</li>
<li>range（索引范围扫描）；</li>
<li>ref（非唯一索引扫描）；</li>
<li>eq_ref（唯一索引扫描）；</li>
<li>const（结果只有一条的主键或唯一索引扫描）。</li>
</ul>
<p>在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。</p>
<p>range 表示采用了索引范围扫描，一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此 需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。</p>
<p>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</p>
<p>eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</p>
<p>const 类型表示使用了主键或者唯一索引与常量值进行比较，比如 select name from product where id&#x3D;1。</p>
<p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。</p>
<blockquote>
<p>除了关注 type， 也要关注 extra 显示的结果。</p>
</blockquote>
<p>这里说几个重要的参考指标：</p>
<ul>
<li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>
<li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>数据库中的事务是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。</p>
<blockquote>
<p>如何开启事务</p>
</blockquote>
<p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p>
<ul>
<li>第一种：begin&#x2F;start transaction 命令；</li>
<li>第二种：start transaction with consistent snapshot 命令；</li>
</ul>
<p>这两种开启事务的命令，事务的启动时机是不同的：</p>
<ul>
<li>执行了 begin&#x2F;start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删改查操作的 SQL 语句，才是事务真正启动的时机；</li>
<li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li>
</ul>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务是由 MySQL 的引擎来实现的， InnoDB 引擎它是支持事务的。</p>
<p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p>
<p>事务必须要遵守 4 个特性，分别如下：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：<strong>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</strong></li>
<li><strong>一致性（Consistency）</strong>：<strong>所谓一致性是数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致。这种一致性是一种需要管理员去定义的规则。管理员如何指定规则，数据库就严格按照这种规则去处理数据。</strong>如果说AB账户总金额5000就是数据库的一致性规则，那么我能不能把A账户转走10000给B，让B账户有10000，而A剩下-5000？从数学上来看完全正确，但这显然是不符合常理的。而这种常理，就是所谓的一致性。</li>
<li><strong>隔离性（Isolation）</strong>：<strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的</strong>。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li>
<li><strong>持久性（Durability）</strong>：<strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</strong></li>
</ul>
<p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p>
<ul>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<h2 id="并发事务有什么问题"><a href="#并发事务有什么问题" class="headerlink" title="并发事务有什么问题"></a>并发事务有什么问题</h2><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p>
<p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/10b513008ea35ee880c592a88adcb12f.png" alt="图片"></p>
<p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p>
<p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p>
<p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p>
<ul>
<li>脏读：读到其他事务未提交的数据；</li>
<li>不可重复读：前后读取的数据不一致；</li>
<li>幻读：前后读取的记录数量不一致。</li>
</ul>
<p>这三个现象的严重性排序如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/d37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p>
<p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p>
<ul>
<li><strong>读未提交（read uncommitted ）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（serializable）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p>按隔离水平高低排序如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/cce766a69dea725cd8f19b90db2d0430.png" alt="图片"></p>
<p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/4e98ea2e60923b969790898565b4d643.png" alt="图片"></p>
<p>也就是说：</p>
<ul>
<li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li>
<li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li>
<li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li>
<li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li>
</ul>
<p>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</p>
<p>不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，<strong>MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入</strong>。</p>
<p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p>
<p>下面例子说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/d5de450e901ed926d0b5278c8b65b9fe.png" alt="图片"></p>
<p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p>
<ul>
<li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li>
<li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li>
<li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li>
<li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li>
</ul>
<p>这四种隔离级别具体是如何实现的呢？</p>
<ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View <strong>来实现的，它们的区别在于创建 Read View 的时机不同， Read View可以理解成一个数据快照。</strong>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li>
</ul>
<h2 id="Read-View-在-MVCC-里如何工作"><a href="#Read-View-在-MVCC-里如何工作" class="headerlink" title="Read View 在 MVCC 里如何工作"></a>Read View 在 MVCC 里如何工作</h2><h3 id="Read-View-是个什么东西"><a href="#Read-View-是个什么东西" class="headerlink" title="Read View 是个什么东西"></a>Read View 是个什么东西</h3><p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<p>Read View 有四个重要的字段：</p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1(如果新开启一个事务，新事务的事务id)；</li>
<li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p>
<p>把两个隐藏列画出来，该记录的整个示意图如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p>在创建 Read View 后，可以将记录中的 trx_id 划分这三种情况：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/ReadView.drawio.png" alt="img"></p>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p>
<h3 id="可重复读是如何工作的"><a href="#可重复读是如何工作的" class="headerlink" title="可重复读是如何工作的"></a>可重复读是如何工作的</h3><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p>
<p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img"></p>
<p>事务 A 和 事务 B 的 Read View 具体内容如下：</p>
<ul>
<li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li>
<li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li>
</ul>
<p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p>
<ul>
<li>事务 B 读取账户余额记录，读到余额是 100 万；</li>
<li>事务 A 将账户余额记录修改成 200 万，并没有提交事务；</li>
<li>事务 B 读取账户余额记录，读到余额还是 100 万；</li>
<li>事务 A 提交事务；</li>
<li>事务 B 读取账户余额记录，读到余额依然还是 100 万；</li>
</ul>
<p>事务 B 第一次读账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p>
<p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png" alt="img"></p>
<p>可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id &#x3D; 51）。</p>
<p>然后事务 B 第二次去读取该记录，**发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 符合要求的记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是余额是 100 万的这条记录。</p>
<p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是余额是 100 万的这条记录</strong>。</p>
<p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p>
<h3 id="读提交是如何工作的"><a href="#读提交是如何工作的" class="headerlink" title="读提交是如何工作的"></a>读提交是如何工作的</h3><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p>
<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p>
<ul>
<li>事务 B 读取数据（创建 Read View），账户余额为 100 万；</li>
<li>事务 A 修改数据（还没提交事务），将账户余额从 100 万修改成了 200 万；</li>
<li>事务 B 读取数据（创建 Read View），账户余额为 100 万；</li>
<li>事务 A 提交事务；</li>
<li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li>
</ul>
<p>那具体怎么做到的呢？事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png" alt="img"></p>
<blockquote>
<p>为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？</p>
</blockquote>
<p>事务 B 在找到这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明<strong>这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录</strong>。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是余额是 100 万的这条记录。</p>
<blockquote>
<p>为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？</p>
</blockquote>
<p>在事务 A 提交后，<strong>由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View</strong>，此时事务 B 第三次读取数据时创建的 Read View 如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img"></p>
<p>事务 B 在找到这条记录时，<strong>会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的</strong>。</p>
<p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<h3 id="可重复读如何很大程度上避免幻读"><a href="#可重复读如何很大程度上避免幻读" class="headerlink" title="可重复读如何很大程度上避免幻读"></a>可重复读如何很大程度上避免幻读</h3><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h4 id="快照读是如何避免幻读的"><a href="#快照读是如何避免幻读的" class="headerlink" title="快照读是如何避免幻读的"></a>快照读是如何避免幻读的</h4><p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
<h4 id="当前读是如何避免幻读的"><a href="#当前读是如何避免幻读的" class="headerlink" title="当前读是如何避免幻读的"></a>当前读是如何避免幻读的</h4><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p>
<p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p>
<p>接下来，假设<code>select ... for update</code>当前读是不会加锁的（实际上是会加锁的），做一遍实验。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/1f872ff92b644b5f81cee2dd9188b199.png" alt="img"></p>
<p>这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。</p>
<p>所以，<strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁</strong>。</p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/gap%E9%94%81.drawio.png" alt="img"></p>
<p>举个具体例子，场景如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3af285a8e70f4d4198318057eb955520.png" alt="img"></p>
<p>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</p>
<p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。</p>
<h4 id="幻读被完全解决了吗"><a href="#幻读被完全解决了吗" class="headerlink" title="幻读被完全解决了吗"></a>幻读被完全解决了吗</h4><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p>
<p>如以下场景：</p>
<h5 id="第一个发生幻读现象的场景"><a href="#第一个发生幻读现象的场景" class="headerlink" title="第一个发生幻读现象的场景"></a>第一个发生幻读现象的场景</h5><p>还是以这张表作为例子：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/7f9df142b3594daeaaca495abb7133f5-20230309222119359.png" alt="img"></p>
<p>事务 A 执行查询 id &#x3D; 5 的记录，此时表中是没有该记录的，所以查询不出来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>然后事务 B 插入一条 id &#x3D; 5 的记录，并且提交了事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 事务 B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t_stu <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;小美&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>此时，<strong>事务 A 更新 id &#x3D; 5 这条记录，对没错，事务 A 看不到 id &#x3D; 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id &#x3D; 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_stu <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小林coding&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 小林coding   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>整个发生幻读的时序图如下：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p>
<p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p>
<p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p>
<h5 id="第二个发生幻读现象的场景"><a href="#第二个发生幻读现象的场景" class="headerlink" title="第二个发生幻读现象的场景"></a>第二个发生幻读现象的场景</h5><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p>
<ul>
<li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li>
<li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li>
<li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ul>
<p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>这两种情况都是先执行了快照读，其他事务可以插入数据，当前事务再使用当前读(当前读并不使用MVCC，它可以看到其他事务插入的数据)此时发生了幻读，而当前读可能会修改记录的trx_id，当前事务再进行快照读还会发生幻读。</p>
<p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="为什么要有-Buffer-Pool？"><a href="#为什么要有-Buffer-Pool？" class="headerlink" title="为什么要有 Buffer Pool？"></a>为什么要有 Buffer Pool？</h2><p>虽然说 MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p>
<p>要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="img"></p>
<p>有了缓冲池后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li>
</ul>
<h3 id="Buffer-Pool-大小"><a href="#Buffer-Pool-大小" class="headerlink" title="Buffer Pool 大小"></a>Buffer Pool 大小</h3><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p>
<p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p>
<h3 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h3><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p>
<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p>所以，MySQL 刚启动的时候，会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/bufferpool%E5%86%85%E5%AE%B9.drawio.png" alt="img"></p>
<p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p>
<p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" alt="img"></p>
<p>上图中控制块和缓存页之间灰色部分称为碎片空间。</p>
<blockquote>
<p>为什么会有碎片空间呢？</p>
</blockquote>
<p>每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小就用不到，这个用不到的内存空间就被称为碎片了。</p>
<p>当然，如果把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。</p>
<blockquote>
<p>查询一条记录，就只需要缓冲一条记录吗？</p>
</blockquote>
<p>不是的。</p>
<p>当查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</p>
<blockquote>
<p>Undo页是干什么的？</p>
</blockquote>
<p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p>
<h2 id="如何管理-Buffer-Pool"><a href="#如何管理-Buffer-Pool" class="headerlink" title="如何管理 Buffer Pool"></a>如何管理 Buffer Pool</h2><h3 id="如何管理空闲页？"><a href="#如何管理空闲页？" class="headerlink" title="如何管理空闲页？"></a>如何管理空闲页？</h3><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p>
<p>那当从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。</p>
<p>所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/freelist.drawio.png" alt="img"></p>
<p>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p>
<p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</p>
<p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p>
<h3 id="如何管理脏页？"><a href="#如何管理脏页？" class="headerlink" title="如何管理脏页？"></a>如何管理脏页？</h3><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p>
<p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/Flush.drawio.png" alt="img"></p>
<p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p>
<h3 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h3><p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。</p>
<p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</p>
<p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p>
<p>简单的 LRU 算法的实现思路是这样的：</p>
<ul>
<li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li>
<li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li>
</ul>
<p>比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有 1，2，3，4，5 的页。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lru.png" alt="img"></p>
<p>如果访问了 3 号的页，因为 3 号页在 Buffer Pool 里，所以把 3 号页移动到头部即可。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lru2.png" alt="img"></p>
<p>而如果接下来，访问了 8 号页，因为 8 号页不在 Buffer Pool 里，所以需要先淘汰末尾的 5 号页，然后再将 8 号页加入到头部。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lru3.png" alt="img"></p>
<p>到这里可以知道，Buffer Pool 里有三种页和链表来管理数据。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpoll_page.png" alt="img"></p>
<p>图中：</p>
<ul>
<li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li>
<li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li>
<li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li>
</ul>
<blockquote>
<p>简单的 LRU 算法有什么问题?</p>
</blockquote>
<ul>
<li>预读失效；</li>
<li>Buffer Pool 污染；</li>
</ul>
<blockquote>
<p>什么是预读失效？</p>
</blockquote>
<p>程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p>
<p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p>
<p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p>
<p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。</p>
<p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p>
<blockquote>
<p>怎么解决预读失效而导致缓存命中率降低的问题？</p>
</blockquote>
<p>不能因为害怕预读失效，而将预读机制去掉，大部分情况下，局部性原理还是成立的。</p>
<p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p>
<blockquote>
<p>MySQL 是怎样做的？</p>
</blockquote>
<p>它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p>
<p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/young+old.png" alt="img"></p>
<p>old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pct</code> 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。</p>
<p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<p>假设有一个长度为 10 的 LRU 链表，其中 young 区域占比 70 %，old 区域占比 30 %。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lrutwo.drawio.png" alt="img"></p>
<p>现在有个编号为 20 的页被预读了，这个页只会被插入到 old 区域头部，而 old 区域末尾的页（10号）会被淘汰掉。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lrutwo2.png" alt="img"></p>
<p>如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。</p>
<p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7号），会被挤到 old 区域，作为 old 区域的头部，这个过程并不会有页被淘汰。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lrutwo3.png" alt="img"></p>
<blockquote>
<p>什么是 Buffer Pool 污染？</p>
</blockquote>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p>
<p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p>
<p>比如，在一个数据量非常大的表，执行了这条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> &quot;%han%&quot;;</span><br></pre></td></tr></table></figure>

<p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p>
<ul>
<li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li>
<li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li>
<li>接下来拿行记录的 name 字段和字符串 han 进行模糊匹配，如果符合条件，就加入到结果集里；</li>
<li>如此往复，直到扫描完表中的所有记录。</li>
</ul>
<p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p>
<p>假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lruthree.drawio.png" alt="img"></p>
<p>在批量访问这些数据的时候，会被逐一插入到 young 区域头部。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/lruthree1.png" alt="img"></p>
<p>可以看到，原本在 young 区域的热点数据 6 和 7 号页都被淘汰了，这就是 Buffer Pool 污染的问题。</p>
<blockquote>
<p>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</p>
</blockquote>
<p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</p>
<p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p>
<blockquote>
<p>MySQL的做法是什么？</p>
</blockquote>
<p>进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p>
<p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会。</p>
<h3 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h3><p>引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。</p>
<p>因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。</p>
<blockquote>
<p>如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不会丢失数据吗？</p>
</blockquote>
<p>InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p>
<p>下面几种情况会触发脏页的刷新：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；(为了防止之后redo log 不能插入数据时宕机导致脏页未被保存也不能使用redo log恢复)</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
<p>在开启了慢 SQL 监控后，如果发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p>
<p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。</p>
<p>执行一条语句是否自动提交事务，是由 <code>autocommit</code> 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。</p>
<blockquote>
<p>那么，如果一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？</p>
</blockquote>
<p>如果每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。</p>
<p>实现这一机制就是 <strong>undo log（回滚日志），它保证了事务的 ACID 中的原子性（Atomicity）</strong>。</p>
<p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png" alt="回滚事务"></p>
<p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p>
<p>不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的.</p>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p>
<ul>
<li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li>
<li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li>
</ul>
<p>版本链如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%89%88%E6%9C%AC%E9%93%BE.png" alt="版本链"></p>
<p>另外，<strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。</p>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同.</p>
<p>因此，undo log 两大作用：</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<blockquote>
<p>undo log 是如何刷盘（持久化到磁盘）的？</p>
</blockquote>
<p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p>
<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>过程如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/wal.png" alt="img"></p>
<blockquote>
<p>什么是 redo log？</p>
</blockquote>
<p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<blockquote>
<p>被修改 Undo 页面，需要记录对应 redo log 吗？</p>
</blockquote>
<p>需要的。</p>
<p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p>
<p>不过，<strong>在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p>
<blockquote>
<p>redo log 和 undo log 区别在哪？</p>
</blockquote>
<p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png" alt="事务恢复"></p>
<p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p>
<blockquote>
<p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p>
</blockquote>
<p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p>
<p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p>
<p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<blockquote>
<p>产生的 redo log 是直接写入磁盘的吗？</p>
</blockquote>
<p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/redologbuf.webp" alt="事务恢复"></p>
<p>redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。</p>
<h3 id="redo-log-什么时候刷盘"><a href="#redo-log-什么时候刷盘" class="headerlink" title="redo log 什么时候刷盘"></a>redo log 什么时候刷盘</h3><blockquote>
<p>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p>
</blockquote>
<p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li>
</ul>
<blockquote>
<p>innodb_flush_log_at_trx_commit 参数控制的是什么？</p>
</blockquote>
<p>单独执行一个更新语句的时候，InnoDB 引擎会自己启动一个事务，在执行更新语句的过程中，生成的 redo log 先写入到 redo log buffer 中，然后等事务提交的时候，再将缓存在 redo log buffer 中的 redo log 按组的方式「顺序写」到磁盘。</p>
<p>上面这种 redo log 刷盘时机是在事务提交的时候，这个默认的行为。</p>
<p>除此之外，InnoDB 还提供了另外两种策略，由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p>
<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache，Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
<p>我画了一个图，方便大家理解：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb_flush_log_at_trx_commit.drawio.png" alt="img"></p>
<blockquote>
<p>innodb_flush_log_at_trx_commit 为 0 和 2 的时候，什么时候才将 redo log 写入磁盘？</p>
</blockquote>
<p>InnoDB 的后台线程每隔 1 秒：</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li>
</ul>
<p>加入了后台现线程后，innodb_flush_log_at_trx_commit 的刷盘时机如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb_flush_log_at_trx_commit2.drawio.png" alt="img"></p>
<blockquote>
<p>这三个参数的应用场景是什么？</p>
</blockquote>
<p>这三个参数的数据安全性和写入性能的比较如下：</p>
<ul>
<li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li>
<li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li>
</ul>
<p>所以，数据安全性和写入性能是熊掌不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p>
<ul>
<li>在一些对数据安全性要求比较高的场景中，显然 <code>innodb_flush_log_at_trx_commit</code> 参数需要设置为 1。</li>
<li>在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0，这样可以明显地减少日志同步到磁盘的 I&#x2F;O 操作。</li>
<li>安全性和性能折中的方案就是参数 2，虽然参数 2 没有参数 0 的性能高，但是数据安全性方面比参数 0 强，因为参数 2 只要操作系统不宕机，即使数据库崩溃了，也不会丢失数据，同时性能方便比参数 1 高。</li>
</ul>
<h3 id="redo-log-文件写满了怎么办"><a href="#redo-log-文件写满了怎么办" class="headerlink" title="redo log 文件写满了怎么办"></a>redo log 文件写满了怎么办</h3><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.drawio.png" alt="重做日志文件组"></p>
<p>在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</p>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<p>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p>
<p>redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。</p>
<p>redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/checkpoint.png" alt="img"></p>
<p>图中的：</p>
<ul>
<li>write pos 和 checkpoint 的移动都是顺时针方向；</li>
<li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p>
<p>所以，一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<blockquote>
<p>为什么有了 binlog， 还要有 redo log？</p>
</blockquote>
<p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p>
<p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p>
<h3 id="redo-log-和-binlog-的区别"><a href="#redo-log-和-binlog-的区别" class="headerlink" title="redo log 和 binlog 的区别"></a>redo log 和 binlog 的区别</h3><p>这两个日志有四个区别。</p>
<p><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 Innodb 存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<blockquote>
<p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p>
</blockquote>
<p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p>
<p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p>
<p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>
<h3 id="主从复制的实现"><a href="#主从复制的实现" class="headerlink" title="主从复制的实现"></a>主从复制的实现</h3><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" alt="MySQL 主从复制过程"></p>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ul>
<p>具体详细过程如下：</p>
<ul>
<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<p>在完成主从复制之后，就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png" alt="MySQL 主从架构"></p>
<blockquote>
<p>从库是不是越多越好？</p>
</blockquote>
<p>不是的。</p>
<p>因为从库数量增加，从库连接上来的 I&#x2F;O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p>
<p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</p>
<blockquote>
<p>MySQL 主从复制还有哪些模型？</p>
</blockquote>
<p>主要有三种：</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li>
</ul>
<h3 id="binlog-什么时候刷盘"><a href="#binlog-什么时候刷盘" class="headerlink" title="binlog 什么时候刷盘"></a>binlog 什么时候刷盘</h3><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p>一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。这是因为有一个线程只能同时有一个事务在执行的设定，所以每当执行一个 begin&#x2F;start transaction 的时候，就会默认提交上一个事务，这样如果一个事务的 binlog 被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破坏了原子性，是有问题的。</p>
<p>MySQL 给每个线程分配了一片内存用于缓冲 binlog ，该内存叫 binlog cache，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<blockquote>
<p>什么时候 binlog cache 会写到 binlog 文件？</p>
</blockquote>
<p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/binlogcache.drawio.png" alt="binlog cach"></p>
<p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p>
<ul>
<li>图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I&#x2F;O。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I&#x2F;O，所以频繁的 fsync 会导致磁盘的 I&#x2F;O 升高。</li>
</ul>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>在MySQL中系统默认的设置是 sync_binlog &#x3D; 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦操作系统发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<p>而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使操作系统发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p>
<p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p>
<p><code>事务提交之前就要发送binlog日志给从库,而保存到磁盘是在提交之后，所以binlog发送给从库是在保存到磁盘之前</code></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><blockquote>
<p>全局锁是怎么用的？</p>
</blockquote>
<p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>当然，当会话断开了，全局锁会被自动释放。</p>
<blockquote>
<p>全局锁应用场景是什么？</p>
</blockquote>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<blockquote>
<p>加全局锁又会带来什么缺点呢？</p>
</blockquote>
<p>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<blockquote>
<p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p>
</blockquote>
<p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><blockquote>
<p>MySQL 表级锁有哪些？具体怎么用的。</p>
</blockquote>
<p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>如果想对学生表（t_student）加表锁，可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>另外，当会话退出后，也会释放所有表锁。</p>
<p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能。</p>
<h3 id="元数据锁-DML"><a href="#元数据锁-DML" class="headerlink" title="元数据锁(DML)"></a>元数据锁(DML)</h3><p>不需要显示的使用 MDL，因为当对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p>
<blockquote>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
</blockquote>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<blockquote>
<p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p>
</blockquote>
<p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>接着，说说<strong>意向锁</strong>。</p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</strong></p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p>
<p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1：<ul>
<li>普通 insert 语句，自增锁在申请之后就马上释放；</li>
<li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
</ul>
<p>当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。</p>
<p>举个例子，考虑下面场景：</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb_autoinc_lock_mode=2.png" alt="img"></p>
<p>session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后<strong>两个 session 同时执行向表 t2 中插入数据</strong>。</p>
<p>如果 innodb_autoinc_lock_mode &#x3D; 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p>
<ul>
<li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A 来申请自增 id 得到 id&#x3D;3，插入了（3,5,5)；</li>
<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li>
</ul>
<p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p>
<p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format&#x3D;statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p>
<p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p>
<p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p>
<p>所以，<strong>当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题</strong>。</p>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<p>普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit &#x3D; 0。</p>
<p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img"></p>
<p>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h3 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h3><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<p>举个例子，当一个事务执行了下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%AE%B0%E5%BD%95%E9%94%81.drawio.png" alt="img"></p>
<p>当事务执行 commit 后，事务过程中生成的锁都会被释放。</p>
<h3 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h3><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/gap%E9%94%81.drawio.png" alt="img"></p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p>
<h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png" alt="img"></p>
<p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<p>比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。</p>
<p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p>
<p><strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/gap%E9%94%81.drawio.png" alt="img"></p>
<p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p>
<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<h3 id="如何分析加了什么锁"><a href="#如何分析加了什么锁" class="headerlink" title="如何分析加了什么锁"></a>如何分析加了什么锁</h3><p>可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p>
<p><img src="/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1a%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90.png" alt="img"></p>
<p>从上图可以看到，共加了两个锁，分别是：</p>
<ul>
<li>表锁：X 类型的意向锁；</li>
<li>行锁：X 类型的记录锁；</li>
</ul>
<p>重点关注行级锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。</p>
<p>通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p>
<ul>
<li>如果 LOCK_MODE 为 <code>X</code>，说明是 next-key 锁；</li>
<li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是记录锁；</li>
<li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是间隙锁；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" data-id="cltu174ta000m48nu9a1temdd" data-title="mysql.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/项目/lottery" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/">lottery.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h1><h2 id="抽奖领域"><a href="#抽奖领域" class="headerlink" title="抽奖领域"></a>抽奖领域</h2><h3 id="抽奖策略"><a href="#抽奖策略" class="headerlink" title="抽奖策略"></a>抽奖策略</h3><p>使用策略模式</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/IDrawAlgorithm.png" alt="IDrawAlgorithm"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDrawAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序启动时初始化概率元祖，在初始化完成后使用过程中不允许修改元祖数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initRateTuple</span><span class="params">(Long strategyId,Integer strategyMode, List&lt;AwardRateInfo&gt; awardRateInfoList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否已经，做了数据初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isExist</span><span class="params">(Long strategyId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SecureRandom 生成随机数，索引到对应的奖品信息返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">randomDraw</span><span class="params">(Long strategyId, List&lt;String&gt; excludeAwardIds)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">IDrawAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契散列增量，逻辑：黄金分割点：(√5 - 1) / 2 = 0.6180339887，Math.pow(2, 32) * 0.6180339887 = 0x61c88647</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组初始化长度 128，保证数据填充时不发生碰撞的最小初始化值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RATE_TUPLE_LENGTH</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放概率与奖品对应的散列结果，strategyId -&gt; rateTuple</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Long, String[]&gt; rateTupleMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 奖品区间概率值，strategyId -&gt; [awardId-&gt;begin、awardId-&gt;end]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Long, List&lt;AwardRateInfo&gt;&gt; awardRateInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">initRateTuple</span><span class="params">(Long strategyId, Integer strategyMode, List&lt;AwardRateInfo&gt; awardRateInfoList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置判断</span></span><br><span class="line">        <span class="keyword">if</span> (isExist(strategyId))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存奖品概率信息</span></span><br><span class="line">        awardRateInfoMap.put(strategyId, awardRateInfoList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非单项概率，不必存入缓存，因为这部分抽奖算法需要实时处理中奖概率。</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.StrategyMode.SINGLE.getCode().equals(strategyMode)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] rateTuple = rateTupleMap.computeIfAbsent(strategyId, k -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[RATE_TUPLE_LENGTH]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        通过斐波那契散列法来填充rateTuple</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExist</span><span class="params">(Long strategyId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> awardRateInfoMap.containsKey(strategyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契（Fibonacci）散列法，计算哈希索引下标值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashIdx</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> val * HASH_INCREMENT + HASH_INCREMENT;</span><br><span class="line">        <span class="keyword">return</span> hashCode &amp; (RATE_TUPLE_LENGTH - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成百位随机抽奖码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 随机值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">generateSecureRandomIntCode</span><span class="params">(<span class="type">int</span> bound)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>().nextInt(bound) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;singleRateRandomDrawAlgorithm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleRateRandomDrawAlgorithm</span> <span class="keyword">extends</span> <span class="title class_">BaseAlgorithm</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomDraw</span><span class="params">(Long strategyId, List&lt;String&gt; excludeAwardIds)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取策略对应的元祖</span></span><br><span class="line">        String[] rateTuple = <span class="built_in">super</span>.rateTupleMap.get(strategyId);</span><br><span class="line">        <span class="keyword">assert</span> rateTuple != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomVal</span> <span class="operator">=</span> <span class="built_in">this</span>.generateSecureRandomIntCode(<span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">super</span>.hashIdx(randomVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> rateTuple[idx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果中奖ID命中排除奖品列表，则返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (excludeAwardIds.contains(awardId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> awardId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;entiretyRateRandomDrawAlgorithm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntiretyRateRandomDrawAlgorithm</span> <span class="keyword">extends</span> <span class="title class_">BaseAlgorithm</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomDraw</span><span class="params">(Long strategyId, List&lt;String&gt; excludeAwardIds)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">differenceDenominator</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排除掉不在抽奖范围的奖品ID集合</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	根据父类的awardRateInfoMap以及参数excludeAwardIds获得在抽奖范围的奖品differenceAwardRateList，及其概率和differenceDenominator</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置判断：奖品列表为0，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (differenceAwardRateList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置判断：奖品列表为1，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (differenceAwardRateList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> differenceAwardRateList.get(<span class="number">0</span>).getAwardId();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取随机概率值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomVal</span> <span class="operator">=</span> <span class="built_in">this</span>.generateSecureRandomIntCode(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环获取奖品</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        通过新的概率分布*100与随机数使用累和概率法来抽奖</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回中奖结果</span></span><br><span class="line">        <span class="keyword">return</span> awardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>简单抽奖算法为什么要使用斐波那契散列法</p>
</blockquote>
<p>1.该开始使用hashmap</p>
<p>​	eg:[a:0.2,b:0.3,c:0.5]，计算时遍历entry数组，进行累加，当大于等于random时抽奖，时间复杂度O(n)。也会有hash冲突。</p>
<p>2.累和数组</p>
<p>​	eg:[0.2,0.5,1]，当使用二分查找时时间复杂度O(logn)。</p>
<p>3.一般hashMap查找都是O(1)复杂度，改变key-&gt;value映射关系，将查询时间复杂度优化为O(1)</p>
<p>​	eg:[0:a,1:a,….,20:b,21:b,…],时间复杂度O(1),但会有</p>
<p>4.上面hashMap存在hash冲突情况，根据上面key从0~100的映射，可以再优化为数组</p>
<p>​	eg:[a,a,a,…,b,b,b,…],时间复杂度O(1),但如果概率和不为100，并不能很好的体现散列的均匀性（可能有其他原因，需要再查找资料）</p>
<p>5.借鉴ThreadLocal的斐波那契散列，来将数组的散列算法进行优化</p>
<p>​	时间复杂度O(1)</p>
<h3 id="抽奖流程"><a href="#抽奖流程" class="headerlink" title="抽奖流程"></a>抽奖流程</h3><p>使用模板模式，在<strong>AbstractDrawBase</strong>中编排抽奖流程，在<strong>DrawExecImpl</strong>中执行具体每一步的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DrawResult <span class="title function_">doDrawExec</span><span class="params">(DrawReq req)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取抽奖策略</span></span><br><span class="line">    <span class="comment">//StrategyRich包含策略id、策略信息、策略详细信息</span></span><br><span class="line">    <span class="type">StrategyRich</span> <span class="variable">strategyRich</span> <span class="operator">=</span> <span class="built_in">super</span>.queryStrategyRich(req.getStrategyId());</span><br><span class="line">    <span class="type">StrategyBriefVO</span> <span class="variable">strategy</span> <span class="operator">=</span> strategyRich.getStrategy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 校验抽奖策略是否已经初始化到内存</span></span><br><span class="line">    <span class="comment">//实际时通过对应抽奖策略的isExist()判断是否初始化和initRateTuple()进行初始化</span></span><br><span class="line">    <span class="built_in">this</span>.checkAndInitRateData(req.getStrategyId(), strategy.getStrategyMode(), strategyRich.getStrategyDetailList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取不在抽奖范围内的列表，包括：奖品库存为空、风控策略、临时调整等</span></span><br><span class="line">    <span class="comment">//由子类实现，实际是通过查询strategy_detail表，查询条件是strategy_id为提供的strategyId and award_surplus_count为0</span></span><br><span class="line">    List&lt;String&gt; excludeAwardIds = <span class="built_in">this</span>.queryExcludeAwardIds(req.getStrategyId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行抽奖算法</span></span><br><span class="line">    <span class="comment">//由子类实现，实际是通过对应抽奖策略的randomDraw(),当抽到奖后通过更新strategy_detail使得award_surplus_count自减，更新条件strategy_id = #&#123;strategyId&#125; AND award_id = #&#123;awardId&#125; AND award_surplus_count &gt; 0</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> <span class="built_in">this</span>.drawAlgorithm(req.getStrategyId(), drawAlgorithmGroup.get(strategy.getStrategyMode()), excludeAwardIds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 包装中奖结果</span></span><br><span class="line">    <span class="keyword">return</span> buildDrawResult(req.getuId(), req.getStrategyId(), awardId, strategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发奖领域"><a href="#发奖领域" class="headerlink" title="发奖领域"></a>发奖领域</h2><p>使用工厂模式</p>
<p>发奖奖品</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/IDistributionGoods.png" alt="IDistributionGoods"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DistributionRes <span class="title function_">doDistribution</span><span class="params">(GoodsReq req)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 模拟调用优惠券发放接口</span></span><br><span class="line">    logger.info(<span class="string">&quot;模拟调用优惠券发放接口 uId：&#123;&#125; awardContent：&#123;&#125;&quot;</span>, req.getuId(), req.getAwardContent());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.更新用户领奖结果</span></span><br><span class="line">    <span class="comment">//实际是修改user_strategy_export表使得发奖状态变为（完成），修改条件u_id = #&#123;uId&#125; AND order_id = #&#123;orderId&#125; AND award_id = #&#123;awardId&#125;</span></span><br><span class="line">    <span class="built_in">super</span>.updateUserAwardState(req.getuId(), req.getOrderId(), req.getAwardId(), Constants.GrantState.COMPLETE.getCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DistributionRes</span>(req.getuId(), Constants.AwardState.SUCCESS.getCode(), Constants.AwardState.SUCCESS.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 奖品发放策略组 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;Integer, IDistributionGoods&gt; goodsMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DescGoods descGoods;<span class="comment">//描述类商品，以文字形式展示给用户</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedeemCodeGoods redeemCodeGoods;<span class="comment">//兑换码类商品</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CouponGoods couponGoods;<span class="comment">//优惠券商品</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PhysicalGoods physicalGoods;<span class="comment">//实物类奖品</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        goodsMap.put(Constants.AwardType.DESC.getCode(), descGoods);</span><br><span class="line">        goodsMap.put(Constants.AwardType.RedeemCodeGoods.getCode(), redeemCodeGoods);</span><br><span class="line">        goodsMap.put(Constants.AwardType.CouponGoods.getCode(), couponGoods);</span><br><span class="line">        goodsMap.put(Constants.AwardType.PhysicalGoods.getCode(), physicalGoods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributionGoodsFactory</span> <span class="keyword">extends</span> <span class="title class_">GoodsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IDistributionGoods <span class="title function_">getDistributionGoodsService</span><span class="params">(Integer awardTye)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goodsMap.get(awardTye);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="活动领域"><a href="#活动领域" class="headerlink" title="活动领域"></a>活动领域</h2><h3 id="状态流转"><a href="#状态流转" class="headerlink" title="状态流转"></a>状态流转</h3><p>使用状态模式</p>
<p>状态流转图</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/image-20230413132358735.png" alt="image-20230413132358735"></p>
<p>活动状态</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/AbstractState.png" alt="AbstractState"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">class</span> <span class="title class_">AbstractState</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">protected</span> IActivityRepository activityRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动提审</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">arraignment</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审核通过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">checkPass</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审核拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">checkRefuse</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 撤审撤销</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">checkRevoke</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">close</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动开启</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">open</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">doing</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> eg：提审状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraignmentState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">arraignment</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Constants.ResponseCode.UNKNOWN_ERROR, <span class="string">&quot;待审核状态不可重复提审&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">checkPass</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;</span><br><span class="line">        <span class="comment">//实际是修改activity表使得state变为需要的状态，修改条件是activity_id = #&#123;activityId&#125; AND state = #&#123;beforeState&#125;</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.PASS);</span><br><span class="line">        <span class="keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="string">&quot;活动审核通过完成&quot;</span>) : Result.buildErrorResult(<span class="string">&quot;活动状态变更失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>活动状态处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提审</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Result <span class="title function_">arraignment</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 审核通过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Result <span class="title function_">checkPass</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateHandlerImpl</span> <span class="keyword">extends</span> <span class="title class_">StateConfig</span> <span class="keyword">implements</span> <span class="title class_">IStateHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">arraignment</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;</span><br><span class="line">        <span class="comment">//实际是调用currentStatus对应状态类的对应方法来实现状态流转</span></span><br><span class="line">        <span class="keyword">return</span> stateGroup.get(currentStatus).arraignment(activityId, currentStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">checkPass</span><span class="params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stateGroup.get(currentStatus).checkPass(activityId, currentStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="活动参与"><a href="#活动参与" class="headerlink" title="活动参与"></a>活动参与</h3><p>使用模板模式</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/ActivityPartakeImpl.png" alt="ActivityPartakeImpl"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IActivityPartake</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参与活动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PartakeResult <span class="title function_">doPartake</span><span class="params">(PartakeReq req)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存奖品单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Result <span class="title function_">recordDrawOrder</span><span class="params">(DrawOrderVO drawOrder)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新发货单MQ状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateInvoiceMqState</span><span class="params">(String uId, Long orderId, Integer mqState)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描发货单 MQ 状态，把未发送 MQ 的单子扫描出来，做补偿</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;InvoiceVO&gt; <span class="title function_">scanInvoiceMqState</span><span class="params">(<span class="type">int</span> dbCount, <span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">BaseActivityPartake</span> <span class="keyword">extends</span> <span class="title class_">ActivityPartakeSupport</span> <span class="keyword">implements</span>  <span class="title class_">IActivityPartake</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Constants.Ids, IIdGenerator&gt; idGeneratorMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PartakeResult <span class="title function_">doPartake</span><span class="params">(PartakeReq req)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询是否存在未执行抽奖领取活动单【user_take_activity 存在 state = 0，领取了但抽奖过程失败的，可以直接返回领取结果继续抽奖】</span></span><br><span class="line">        <span class="comment">//由子类实现，实际是查询user_take_activity，查询条件为u_id = #&#123;uId&#125; AND activity_id = #&#123;activityId&#125; AND state = 0 ORDER BY id DESC LIMIT 1</span></span><br><span class="line">        <span class="type">UserTakeActivityVO</span> <span class="variable">userTakeActivityVO</span> <span class="operator">=</span> <span class="built_in">this</span>.queryNoConsumedTakeActivityOrder(req.getActivityId(), req.getuId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != userTakeActivityVO) &#123;</span><br><span class="line">            <span class="keyword">return</span> buildPartakeResult(userTakeActivityVO.getStrategyId(), userTakeActivityVO.getTakeId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查询活动账单</span></span><br><span class="line">        <span class="comment">//实际是查询activity表，通过activity_id查询；以及通过u_id和activity_id查询user_take_activity_count。以获取activity信息以及剩余领取次数</span></span><br><span class="line">        <span class="type">ActivityBillVO</span> <span class="variable">activityBillVO</span> <span class="operator">=</span> <span class="built_in">super</span>.queryActivityBill(req);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 活动信息校验处理</span></span><br><span class="line">        <span class="comment">//由子类实现，实际是校验【活动库存、状态、日期、剩余参与次数】</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">checkResult</span> <span class="operator">=</span> <span class="built_in">this</span>.checkActivityBill(req, activityBillVO);</span><br><span class="line">        <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(checkResult.getCode())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PartakeResult</span>(checkResult.getCode(), checkResult.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 扣减活动库存【目前为直接对配置库中的 lottery.activity 直接操作表扣减库存，后续优化为Redis扣减】</span></span><br><span class="line">        <span class="comment">//实际是更新activity使得stock_surplus_coun--,更新条件activity_id = #&#123;activityId&#125; AND stock_surplus_count &gt; 0</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">subtractionActivityResult</span> <span class="operator">=</span> <span class="built_in">this</span>.subtractionActivityStock(req);</span><br><span class="line">        <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(subtractionActivityResult.getCode())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PartakeResult</span>(subtractionActivityResult.getCode(), subtractionActivityResult.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 插入领取活动信息【个人用户把活动信息写入到用户表】</span></span><br><span class="line">        <span class="comment">//活动参与id-&gt;雪花算法</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">takeId</span> <span class="operator">=</span> idGeneratorMap.get(Constants.Ids.SnowFlake).nextId();</span><br><span class="line">        <span class="comment">//由子类实现，在一个事务里，实际是去user_take_activity_count更新left_count--,更新条件u_id = #&#123;uId&#125; AND activity_id = #&#123;activityId&#125; AND left_count &gt; 0，目的是更新个人剩余参与次数；去user_take_activity新增一条用户参与记录，其中take_count为activity.take_count - user_take_left_count、防重id-uuid为uId + &quot;_&quot; + activityId + &quot;_&quot; + userTakeActivity.getTakeCount();</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">grabResult</span> <span class="operator">=</span> <span class="built_in">this</span>.grabActivity(req, activityBillVO, takeId);</span><br><span class="line">        <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(grabResult.getCode())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PartakeResult</span>(grabResult.getCode(), grabResult.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildPartakeResult(activityBillVO.getStrategyId(), takeId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="规则引擎领域"><a href="#规则引擎领域" class="headerlink" title="规则引擎领域"></a>规则引擎领域</h2><p>组合模式</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/image-20230418123945108.png" alt="image-20230418123945108"></p>
<p>表设计</p>
<p><strong>rule_tree</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `rule_tree` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tree_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则树NAME&#x27;</span>,</span><br><span class="line">  `tree_desc` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则树描述&#x27;</span>,</span><br><span class="line">  `tree_root_node_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则树根ID&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10002</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>rule_tree_node</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `rule_tree_node` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tree_id` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则树ID&#x27;</span>,</span><br><span class="line">  `node_type` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;节点类型；1子叶、2果实&#x27;</span>,</span><br><span class="line">  `node_value` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;节点值[nodeType=2]；果实值&#x27;</span>,</span><br><span class="line">  `rule_key` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则Key&#x27;</span>,</span><br><span class="line">  `rule_desc` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则描述&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">123</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>rule_tree_node_line</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `rule_tree_node_line` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tree_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则树ID&#x27;</span>,</span><br><span class="line">  `node_id_from` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;节点From&#x27;</span>,</span><br><span class="line">  `node_id_to` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;节点To&#x27;</span>,</span><br><span class="line">  `rule_limit_type` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;限定类型；1:=;2:&gt;;3:&lt;;4:&gt;=;5&lt;=;6:enum[枚举范围];7:果实&#x27;</span>,</span><br><span class="line">  `rule_limit_value` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;限定值&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">7</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要让逻辑过滤器和规则过滤器分开实现</p>
</blockquote>
<p>规则过滤器是根据treeId和入参，来实现从根节点到叶子节点的整体流程。规则过滤器就相当于实现整体流程中的每一个具体过程，而且其中树的遍历（层序）难免会涉及到不同种的过滤规则，需要实现“逻辑过滤”接口来定制化不同的规则过滤器。</p>
<h3 id="逻辑过滤"><a href="#逻辑过滤" class="headerlink" title="逻辑过滤"></a>逻辑过滤</h3><p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/LogicFilter.png" alt="LogicFilter"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogicFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑决策器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matterValue          决策值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeNodeLineInfoList 决策节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                     下一个节点Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">filter</span><span class="params">(String matterValue, List&lt;TreeNodeLineVO&gt; treeNodeLineInfoList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取决策值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> decisionMatter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">matterValue</span><span class="params">(DecisionMatterReq decisionMatter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseLogic</span> <span class="keyword">implements</span> <span class="title class_">LogicFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">filter</span><span class="params">(String matterValue, List&lt;TreeNodeLineVO&gt; treeNodeLineInfoList)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历treeNodeLine（其实就是以当前节点为起点的树径），根据他们的决策规则，选择下一步的树节点id</span></span><br><span class="line">        <span class="keyword">for</span>(TreeNodeLineVO nodeLine : treeNodeLineInfoList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(decisionLogic(matterValue, nodeLine))&#123;</span><br><span class="line">                <span class="keyword">return</span> nodeLine.getNodeIdTo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Constants.Global.TREE_NULL_NODE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取规则比对值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">abstract</span> String <span class="title function_">matterValue</span><span class="params">(DecisionMatterReq decisionMatter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *根据决策值和树径选择是否走该树径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>  <span class="title function_">decisionLogic</span><span class="params">(String matterValue, TreeNodeLineVO nodeLine)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (nodeLine.getRuleLimitType())&#123;</span><br><span class="line">            <span class="keyword">case</span> Constants.RuleLimitType.EQUAL:</span><br><span class="line">                <span class="keyword">return</span> matterValue.equals(nodeLine.getRuleLimitValue());</span><br><span class="line">            <span class="keyword">case</span> Constants.RuleLimitType.GT:</span><br><span class="line">                <span class="keyword">return</span> Double.parseDouble(matterValue) &gt; Double.parseDouble(nodeLine.getRuleLimitValue());</span><br><span class="line">            <span class="keyword">case</span> Constants.RuleLimitType.LT:</span><br><span class="line">                <span class="keyword">return</span> Double.parseDouble(matterValue) &lt; Double.parseDouble(nodeLine.getRuleLimitValue());</span><br><span class="line">            <span class="keyword">case</span> Constants.RuleLimitType.GE:</span><br><span class="line">                <span class="keyword">return</span> Double.parseDouble(matterValue) &gt;= Double.parseDouble(nodeLine.getRuleLimitValue());</span><br><span class="line">            <span class="keyword">case</span> Constants.RuleLimitType.LE:</span><br><span class="line">                <span class="keyword">return</span> Double.parseDouble(matterValue) &lt;= Double.parseDouble(nodeLine.getRuleLimitValue());</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*年龄逻辑过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAgeFilter</span> <span class="keyword">extends</span> <span class="title class_">BaseLogic</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">matterValue</span><span class="params">(DecisionMatterReq decisionMatter)</span> &#123;</span><br><span class="line">        <span class="comment">//实际上获取根据规则引擎传递的参数（接口传递的参数）中的值</span></span><br><span class="line">        <span class="comment">//eg:&#123;age:10,gender:man&#125;获取age对应的值。</span></span><br><span class="line">        <span class="keyword">return</span> decisionMatter.getValMap().get(<span class="string">&quot;age&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*性别逻辑过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserGenderFilter</span> <span class="keyword">extends</span> <span class="title class_">BaseLogic</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">matterValue</span><span class="params">(DecisionMatterReq decisionMatter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decisionMatter.getValMap().get(<span class="string">&quot;gender&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/RuleEngineHandle.png" alt="RuleEngineHandle"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EngineFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 规则过滤器接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EngineResult <span class="title function_">process</span><span class="params">(<span class="keyword">final</span> DecisionMatterReq matter)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EngineBase</span> <span class="keyword">extends</span> <span class="title class_">EngineConfig</span> <span class="keyword">implements</span> <span class="title class_">EngineFilter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由子类去实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EngineResult <span class="title function_">process</span><span class="params">(DecisionMatterReq matter)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;未实现规则引擎服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *子类调用该方法，用于根据逻辑过滤器去寻找最终的叶子节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> TreeNodeVO <span class="title function_">engineDecisionMaker</span><span class="params">(TreeRuleRich treeRuleRich, DecisionMatterReq matter)</span> &#123;</span><br><span class="line">        <span class="type">TreeRootVO</span> <span class="variable">treeRoot</span> <span class="operator">=</span> treeRuleRich.getTreeRoot();</span><br><span class="line">        Map&lt;Long, TreeNodeVO&gt; treeNodeMap = treeRuleRich.getTreeNodeMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 规则树根ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">rootNodeId</span> <span class="operator">=</span> treeRoot.getTreeRootNodeId();</span><br><span class="line">        <span class="type">TreeNodeVO</span> <span class="variable">treeNodeInfo</span> <span class="operator">=</span> treeNodeMap.get(rootNodeId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点类型[NodeType]；1子叶、2果实</span></span><br><span class="line">        <span class="keyword">while</span> (Constants.NodeType.STEM.equals(treeNodeInfo.getNodeType())) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点(不断遍历更新)规则</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ruleKey</span> <span class="operator">=</span> treeNodeInfo.getRuleKey();</span><br><span class="line">            <span class="comment">//获取对应逻辑过滤器</span></span><br><span class="line">            <span class="type">LogicFilter</span> <span class="variable">logicFilter</span> <span class="operator">=</span> logicFilterMap.get(ruleKey);<span class="comment">//logicFilterMap在EngineConfig中初始化，规则与逻辑过滤器映射</span></span><br><span class="line">            <span class="comment">//获取决策值，实际入参matter里传递的值，eg:matter里保存了&#123;age:10,gender:man&#125;，如果是年龄过滤器就是获取age对应的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">matterValue</span> <span class="operator">=</span> logicFilter.matterValue(matter);</span><br><span class="line">            <span class="comment">//获取下一个节点id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">nextNode</span> <span class="operator">=</span> logicFilter.filter(matterValue, treeNodeInfo.getTreeNodeLineInfoList());</span><br><span class="line">            <span class="comment">//获取下一个节点</span></span><br><span class="line">            treeNodeInfo = treeNodeMap.get(nextNode);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;决策树引擎=&gt;&#123;&#125; userId：&#123;&#125; treeId：&#123;&#125; treeNode：&#123;&#125; ruleKey：&#123;&#125; matterValue：&#123;&#125;&quot;</span>,</span><br><span class="line">                    treeRoot.getTreeName(), matter.getUserId(), matter.getTreeId(), treeNodeInfo.getTreeNodeId(), ruleKey, matterValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> treeNodeInfo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleEngineHandle</span> <span class="keyword">extends</span> <span class="title class_">EngineBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IRuleRepository ruleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EngineResult <span class="title function_">process</span><span class="params">(DecisionMatterReq matter)</span> &#123;</span><br><span class="line">        <span class="comment">// 决策规则树</span></span><br><span class="line">        <span class="type">TreeRuleRich</span> <span class="variable">treeRuleRich</span> <span class="operator">=</span> ruleRepository.queryTreeRuleRich(matter.getTreeId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == treeRuleRich) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Tree Rule is null!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 决策节点</span></span><br><span class="line">        <span class="type">TreeNodeVO</span> <span class="variable">treeNodeInfo</span> <span class="operator">=</span> engineDecisionMaker(treeRuleRich, matter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 决策结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EngineResult</span>(matter.getUserId(), treeNodeInfo.getTreeId(), treeNodeInfo.getTreeNodeId(), treeNodeInfo.getNodeValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="抽奖过程"><a href="#抽奖过程" class="headerlink" title="抽奖过程"></a>抽奖过程</h2><p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/image-20230416121407965.png" alt="image-20230416121407965"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IActivityProcess</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行抽奖流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DrawProcessResult <span class="title function_">doDrawProcess</span><span class="params">(DrawProcessReq req)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 规则量化人群，返回可参与的活动ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RuleQuantificationCrowdResult <span class="title function_">doRuleQuantificationCrowd</span><span class="params">(DecisionMatterReq req)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DrawProcessResult <span class="title function_">doDrawProcess</span><span class="params">(DrawProcessReq req)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 领取活动</span></span><br><span class="line">    <span class="type">PartakeResult</span> <span class="variable">partakeResult</span> <span class="operator">=</span> activityPartake.doPartake(<span class="keyword">new</span> <span class="title class_">PartakeReq</span>(req.getuId(), req.getActivityId()));</span><br><span class="line">    <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(partakeResult.getCode())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawProcessResult</span>(partakeResult.getCode(), partakeResult.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">strategyId</span> <span class="operator">=</span> partakeResult.getStrategyId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">takeId</span> <span class="operator">=</span> partakeResult.getTakeId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行抽奖</span></span><br><span class="line">    <span class="type">DrawResult</span> <span class="variable">drawResult</span> <span class="operator">=</span> drawExec.doDrawExec(<span class="keyword">new</span> <span class="title class_">DrawReq</span>(req.getuId(), strategyId));</span><br><span class="line">    <span class="keyword">if</span> (Constants.DrawState.FAIL.getCode().equals(drawResult.getDrawState())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawProcessResult</span>(Constants.ResponseCode.LOSING_DRAW.getCode(), Constants.ResponseCode.LOSING_DRAW.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DrawAwardVO</span> <span class="variable">drawAwardVO</span> <span class="operator">=</span> drawResult.getDrawAwardInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 结果落库</span></span><br><span class="line">    <span class="type">DrawOrderVO</span> <span class="variable">drawOrderVO</span> <span class="operator">=</span> buildDrawOrderVO(req, strategyId, takeId, drawAwardVO);</span><br><span class="line">    <span class="type">Result</span> <span class="variable">recordResult</span> <span class="operator">=</span> activityPartake.recordDrawOrder(drawOrderVO);</span><br><span class="line">    <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(recordResult.getCode())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawProcessResult</span>(recordResult.getCode(), recordResult.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 发送MQ，触发发奖流程</span></span><br><span class="line">    <span class="type">InvoiceVO</span> <span class="variable">invoiceVO</span> <span class="operator">=</span> buildInvoiceVO(drawOrderVO);</span><br><span class="line">    ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaProducer.sendLotteryInvoice(invoiceVO);</span><br><span class="line">    future.addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> &#123;</span><br><span class="line">            <span class="comment">// 4.1 MQ 消息发送完成，更新数据库表 user_strategy_export.mq_state = 1</span></span><br><span class="line">            activityPartake.updateInvoiceMqState(invoiceVO.getuId(), invoiceVO.getOrderId(), Constants.MQState.COMPLETE.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">            <span class="comment">// 4.2 MQ 消息发送失败，更新数据库表 user_strategy_export.mq_state = 2 【等待定时任务扫码补偿MQ消息】</span></span><br><span class="line">            activityPartake.updateInvoiceMqState(invoiceVO.getuId(), invoiceVO.getOrderId(), Constants.MQState.FAIL.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawProcessResult</span>(Constants.ResponseCode.SUCCESS.getCode(), Constants.ResponseCode.SUCCESS.getInfo(), drawAwardVO);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RuleQuantificationCrowdResult <span class="title function_">doRuleQuantificationCrowd</span><span class="params">(DecisionMatterReq req)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 量化决策</span></span><br><span class="line">    <span class="type">EngineResult</span> <span class="variable">engineResult</span> <span class="operator">=</span> engineFilter.process(req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!engineResult.isSuccess())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RuleQuantificationCrowdResult</span>(Constants.ResponseCode.RULE_ERR.getCode(),Constants.ResponseCode.RULE_ERR.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 封装结果</span></span><br><span class="line">    <span class="type">RuleQuantificationCrowdResult</span> <span class="variable">ruleQuantificationCrowdResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuleQuantificationCrowdResult</span>(Constants.ResponseCode.SUCCESS.getCode(), Constants.ResponseCode.SUCCESS.getInfo());</span><br><span class="line">    ruleQuantificationCrowdResult.setActivityId(Long.valueOf(engineResult.getNodeValue()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ruleQuantificationCrowdResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LotteryActivityBooth</span> <span class="keyword">implements</span> <span class="title class_">ILotteryActivityBooth</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IActivityProcess activityProcess;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMapping&lt;DrawAwardVO, AwardDTO&gt; awardMapping;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DrawRes <span class="title function_">doDraw</span><span class="params">(DrawReq drawReq)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;抽奖，开始 uId：&#123;&#125; activityId：&#123;&#125;&quot;</span>, drawReq.getUId(), drawReq.getActivityId());</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1. 执行抽奖</span></span><br><span class="line">           <span class="type">DrawProcessResult</span> <span class="variable">drawProcessResult</span> <span class="operator">=</span> activityProcess.doDrawProcess(<span class="keyword">new</span> <span class="title class_">DrawProcessReq</span>(drawReq.getUId(), drawReq.getActivityId()));</span><br><span class="line">           <span class="keyword">if</span>(!Constants.ResponseCode.SUCCESS.getCode().equals(drawProcessResult.getCode()))&#123;</span><br><span class="line">               log.error(<span class="string">&quot;抽奖，失败(抽奖过程异常) uId：&#123;&#125; activityId：&#123;&#125;&quot;</span>, drawReq.getUId(), drawReq.getActivityId());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawRes</span>(drawProcessResult.getCode(), drawProcessResult.getInfo());</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> drawRes;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// TODO 量化人群抽奖细节</span></span><br><span class="line">    <span class="keyword">public</span> DrawRes <span class="title function_">doQuantificationDraw</span><span class="params">(QuantificationDrawReq quantificationDrawReq)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;量化人群抽奖，开始 uId：&#123;&#125; treeId：&#123;&#125;&quot;</span>, quantificationDrawReq.getuId(), quantificationDrawReq.getTreeId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 执行规则引擎，获取用户可以参与的活动号</span></span><br><span class="line">            <span class="type">RuleQuantificationCrowdResult</span> <span class="variable">ruleQuantificationCrowdResult</span> <span class="operator">=</span> activityProcess.doRuleQuantificationCrowd(<span class="keyword">new</span> <span class="title class_">DecisionMatterReq</span>(quantificationDrawReq.getuId(),</span><br><span class="line">                    quantificationDrawReq.getTreeId(), quantificationDrawReq.getValMap()));</span><br><span class="line">            <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(ruleQuantificationCrowdResult.getCode())) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;量化人群抽奖，失败(规则引擎执行异常) uId：&#123;&#125; treeId：&#123;&#125;&quot;</span>, quantificationDrawReq.getuId(), quantificationDrawReq.getTreeId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawRes</span>(ruleQuantificationCrowdResult.getCode(), ruleQuantificationCrowdResult.getInfo());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 执行抽奖</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">activityId</span> <span class="operator">=</span> ruleQuantificationCrowdResult.getActivityId();</span><br><span class="line">            <span class="type">DrawProcessResult</span> <span class="variable">drawProcessResult</span> <span class="operator">=</span> activityProcess.doDrawProcess(<span class="keyword">new</span> <span class="title class_">DrawProcessReq</span>(quantificationDrawReq.getuId(), activityId));</span><br><span class="line">            <span class="keyword">if</span> (!Constants.ResponseCode.SUCCESS.getCode().equals(drawProcessResult.getCode())) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;量化人群抽奖，失败(抽奖过程异常) uId：&#123;&#125; treeId：&#123;&#125;&quot;</span>, quantificationDrawReq.getuId(), quantificationDrawReq.getTreeId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawRes</span>(drawProcessResult.getCode(), drawProcessResult.getInfo());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;量化人群抽奖，完成 uId：&#123;&#125; treeId：&#123;&#125; drawRes：&#123;&#125;&quot;</span>, quantificationDrawReq.getuId(), quantificationDrawReq.getTreeId(), JSON.toJSONString(drawRes));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> drawRes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           	...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Kafka使用"><a href="#Kafka使用" class="headerlink" title="Kafka使用"></a>Kafka使用</h1><p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/image-20230423164122783.png" alt="image-20230423164122783"></p>
<p>在应用层-抽奖流程中将“抽奖”和“发奖”进行解耦，以提高响应速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DrawProcessResult <span class="title function_">doDrawProcess</span><span class="params">(DrawProcessReq req)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 领取活动</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行抽奖</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 结果落库</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 发送MQ，触发发奖流程</span></span><br><span class="line">    <span class="type">InvoiceVO</span> <span class="variable">invoiceVO</span> <span class="operator">=</span> buildInvoiceVO(drawOrderVO);</span><br><span class="line">    ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaProducer.sendLotteryInvoice(invoiceVO);</span><br><span class="line">    future.addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> &#123;</span><br><span class="line">            <span class="comment">// 4.1 MQ 消息发送完成，更新数据库表 user_strategy_export.mq_state = 1</span></span><br><span class="line">            activityPartake.updateInvoiceMqState(invoiceVO.getuId(), invoiceVO.getOrderId(), Constants.MQState.COMPLETE.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">            <span class="comment">// 4.2 MQ 消息发送失败，更新数据库表 user_strategy_export.mq_state = 2 【等待定时任务扫码补偿MQ消息】</span></span><br><span class="line">            activityPartake.updateInvoiceMqState(invoiceVO.getuId(), invoiceVO.getOrderId(), Constants.MQState.FAIL.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawProcessResult</span>(Constants.ResponseCode.SUCCESS.getCode(), Constants.ResponseCode.SUCCESS.getInfo(), drawAwardVO);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MQ 主题： 中奖发货单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC_INVOICE</span> <span class="operator">=</span> <span class="string">&quot;lottery_invoice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送中奖货物发货单消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; <span class="title function_">sendLotteryInvoice</span><span class="params">(InvoiceVO invoice)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">objJson</span> <span class="operator">=</span> JSON.toJSONString(invoice);</span><br><span class="line">        log.info(<span class="string">&quot;发送MQ消息 topic：&#123;&#125; bizId：&#123;&#125; message：&#123;&#125;&quot;</span>, TOPIC_INVOICE, invoice.getuId(), objJson);</span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(TOPIC_INVOICE, objJson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LotteryInvoiceListener</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DistributionGoodsFactory distributionGoodsFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;lottery_invoice&quot;, groupId = &quot;lottery&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span>&#123;</span><br><span class="line">        Optional&lt;?&gt; message = Optional.ofNullable(record.value());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断消息是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!message.isPresent())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理 MQ 消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 转化对象</span></span><br><span class="line">            <span class="type">InvoiceVO</span> <span class="variable">invoiceVO</span> <span class="operator">=</span> JSON.parseObject((String) message.get(), InvoiceVO.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 获取发送奖品工厂，执行发奖</span></span><br><span class="line">            <span class="type">IDistributionGoods</span> <span class="variable">distributionGoodsService</span> <span class="operator">=</span>  distributionGoodsFactory.getDistributionGoodsService(invoiceVO.getAwardType());</span><br><span class="line">            <span class="type">DistributionRes</span> <span class="variable">distributionRes</span> <span class="operator">=</span> distributionGoodsService.doDistribution(<span class="keyword">new</span> <span class="title class_">GoodsReq</span>(invoiceVO.getuId(), invoiceVO.getOrderId(),</span><br><span class="line">                    invoiceVO.getAwardId(), invoiceVO.getAwardName(), invoiceVO.getAwardContent()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 打印日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消费MQ消息，完成 topic：&#123;&#125; bizId：&#123;&#125; 发奖结果：&#123;&#125;&quot;</span>, topic, invoiceVO.getuId(), JSON.toJSONString(distributionRes));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 消息消费完成</span></span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 发奖环节失败，消息重试。所有到环节，发货、更新库，都需要保证幂等。</span></span><br><span class="line">            log.error(<span class="string">&quot;消费MQ消息，失败 topic：&#123;&#125; message：&#123;&#125;&quot;</span>, topic, message.get());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="xxl-job使用"><a href="#xxl-job使用" class="headerlink" title="xxl-job使用"></a>xxl-job使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LotteryXxlJob</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *当ActivityState为PASS更新为DOING</span></span><br><span class="line"><span class="comment">    *当ActivityState为DOING且已经到了结束时间，更新为CLOSED</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;lotteryActivityStateJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lotteryActivityStateJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;扫描活动状态 Begin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取前十个活动状态为PASS或DOING的活动</span></span><br><span class="line">        List&lt;ActivityVO&gt; activityVOList = activityDeploy.scanToDoActivityList(<span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">if</span> (activityVOList.isEmpty())&#123;</span><br><span class="line">            log.info(<span class="string">&quot;扫描活动状态 End 暂无符合需要扫描的活动列表&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!activityVOList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ActivityVO activityVO : activityVOList) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">state</span> <span class="operator">=</span> activityVO.getState();</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="comment">// 活动状态为审核通过，在临近活动开启时间前，审核活动为活动中。在使用活动的时候，需要依照活动状态核时间两个字段进行判断和使用。</span></span><br><span class="line">                    <span class="keyword">case</span> ActivityState.PASS:</span><br><span class="line">                        <span class="type">Result</span> <span class="variable">state4Result</span> <span class="operator">=</span> stateHandler.doing(activityVO.getActivityId(), Constants.ActivityState.PASS);</span><br><span class="line">                        log.info(<span class="string">&quot;扫描活动状态为活动中 结果：&#123;&#125; activityId：&#123;&#125; activityName：&#123;&#125; creator：&#123;&#125;&quot;</span>, JSON.toJSONString(state4Result), activityVO.getActivityId(), activityVO.getActivityName(), activityVO.getCreator());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 扫描时间已过期的活动，从活动中状态变更为关闭状态【这里也可以细化为2个任务来处理，也可以把时间判断放到数据库中操作】</span></span><br><span class="line">                    <span class="keyword">case</span> ActivityState.DOING:</span><br><span class="line">                        <span class="keyword">if</span> (activityVO.getEndDateTime().before(<span class="keyword">new</span> <span class="title class_">Date</span>()))&#123;</span><br><span class="line">                            <span class="type">Result</span> <span class="variable">state5Result</span> <span class="operator">=</span> stateHandler.close(activityVO.getActivityId(), Constants.ActivityState.DOING);</span><br><span class="line">                            log.info(<span class="string">&quot;扫描活动状态为关闭 结果：&#123;&#125; activityId：&#123;&#125; activityName：&#123;&#125; creator：&#123;&#125;&quot;</span>, JSON.toJSONString(state5Result), activityVO.getActivityId(), activityVO.getActivityName(), activityVO.getCreator());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续扫描接下来符合PASS和DOING的activity的10条记录</span></span><br><span class="line">            <span class="type">ActivityVO</span> <span class="variable">activityVO</span> <span class="operator">=</span> activityVOList.get(activityVOList.size() - <span class="number">1</span>);</span><br><span class="line">            activityVOList = activityDeploy.scanToDoActivityList(activityVO.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;扫描活动状态 End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;lotteryOrderMQStateJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lotteryOrderMQStateJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;     </span><br><span class="line">        <span class="comment">// 扫描库表数据,查询mq状态为失败的活动</span></span><br><span class="line">        List&lt;InvoiceVO&gt; invoiceVOList = activityPartake.scanInvoiceMqState(dbCount, i);</span><br><span class="line">        log.info(<span class="string">&quot;扫描用户抽奖奖品发放MQ状态[Table = 2*4] 扫描库：&#123;&#125; 扫描表：&#123;&#125; 扫描数：&#123;&#125;&quot;</span>, dbCount, i, invoiceVOList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 补偿 MQ 消息</span></span><br><span class="line">        <span class="keyword">for</span> (InvoiceVO invoiceVO : invoiceVOList) &#123;</span><br><span class="line"></span><br><span class="line">            ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaProducer.sendLotteryInvoice(invoiceVO);</span><br><span class="line">            future.addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> &#123;</span><br><span class="line">                    <span class="comment">// MQ 消息发送完成，更新数据库表 user_strategy_export.mq_state = 1</span></span><br><span class="line">                    activityPartake.updateInvoiceMqState(invoiceVO.getuId(), invoiceVO.getOrderId(), Constants.MQState.COMPLETE.getCode());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    <span class="comment">// MQ 消息发送失败，更新数据库表 user_strategy_export.mq_state = 2 【等待定时任务扫码补偿MQ消息】</span></span><br><span class="line">                    activityPartake.updateInvoiceMqState(invoiceVO.getuId(), invoiceVO.getOrderId(), Constants.MQState.FAIL.getCode());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E9%A1%B9%E7%9B%AE/lottery/" data-id="cltu174tb000o48nu1bm31f95" data-title="lottery.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/框架/spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/">Spring.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><h2 id="什么是IoC"><a href="#什么是IoC" class="headerlink" title="什么是IoC"></a>什么是IoC</h2><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p>
<p><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</p>
<p><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</p>
<p>我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）</p>
<p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p>
<ol>
<li>对象之间的耦合度或者说依赖程度降低；</li>
<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li>
</ol>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p>AOP：Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。</p>
<p><strong>切</strong> ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑</p>
<p><strong>面</strong> ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念</p>
<p>下面我们先看一个 OOP 的例子。</p>
<p>例如：现有三个类，<code>Horse</code>、<code>Pig</code>、<code>Dog</code>，这三个类中都有 eat 和 run 两个方法。</p>
<p>通过 OOP 思想中的继承，我们可以提取出一个 Animal 的父类，然后将 eat 和 run 方法放入父类中，<code>Horse</code>、<code>Pig</code>、<code>Dog</code>通过继承<code>Animal</code>类即可自动获得 <code>eat()</code> 和 <code>run()</code> 方法。这样将会少些很多重复的代码。</p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230419191250569.png" alt="image-20230419191250569"></p>
<p>OOP 编程思想可以解决大部分的代码重复问题。但是有一些问题是处理不了的。比如在父类 Animal 中的多个方法的相同位置出现了重复的代码，OOP 就解决不了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动物父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 身高 */</span></span><br><span class="line">    <span class="keyword">private</span> String height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 体重 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 性能监控代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;I can eat...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 性能监控代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + (System.currentTimeMillis() - start)/<span class="number">1000f</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 性能监控代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;I can run...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 性能监控代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + (System.currentTimeMillis() - start)/<span class="number">1000f</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分重复的代码，一般统称为 <strong>横切逻辑代码</strong>。</p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230419191300592.png" alt="image-20230419191300592"></p>
<p>横切逻辑代码存在的问题：</p>
<ul>
<li>代码重复问题</li>
<li>横切逻辑代码和业务代码混杂在一起，代码臃肿，不变维护</li>
</ul>
<p><strong>AOP 就是用来解决这些问题的</strong></p>
<p>AOP 另辟蹊径，提出横向抽取机制，将横切逻辑代码和业务逻辑代码分离</p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230419191309990.png" alt="image-20230419191309990"></p>
<p>代码拆分比较容易，难的是如何在不改变原有业务逻辑的情况下，悄无声息的将横向逻辑代码应用到原有的业务逻辑中，达到和原来一样的效果。</p>
<h2 id="AOP作用"><a href="#AOP作用" class="headerlink" title="AOP作用"></a>AOP作用</h2><p>在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。</p>
<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230517233907845.png" alt="image-20230517233907845"></p>
<p>①通过BeanDefinition获取bean的定义信息</p>
<p>②调用构造函数实例化bean</p>
<p>③完成bean的依赖注入</p>
<p>④执行实现Aware接口的方法(BeanNameAware、BeanFactoryAware、ApplicationContextAware)</p>
<p>⑤Bean的后置处理器BeanPostProcessor的前置方法</p>
<p>⑥执行初始化方法(实现InitializingBean的init-method)</p>
<p>⑦Bean的后置处理器BeanPostProcessor的后置方法</p>
<p>⑧销毁bean</p>
<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518110201429.png" alt="image-20230518110201429"></p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518110142352.png" alt="image-20230518110142352"></p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518110234934.png" alt="image-20230518110234934"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518113903564.png" alt="image-20230518113903564"></p>
<h2 id="事务异常"><a href="#事务异常" class="headerlink" title="事务异常"></a>事务异常</h2><p>①异常捕获处理，自己处理了异常，没有抛出。解决方法：手动抛出</p>
<p>②抛出检查异常。解决方法：配置rollbackFor属性为Exception</p>
<p>③非public方法导致的事务失效。解决方法：改为public</p>
<h1 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h1><p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518122802092.png" alt="image-20230518122802092"></p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518122822073.png" alt="image-20230518122822073"></p>
<p><img src="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/image-20230518122907380.png" alt="image-20230518122907380"></p>
<h1 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h1><p>1.在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p>
<ul>
<li><p>@SpringBootConfiguration</p>
</li>
<li><p>@EnableAutoConfiguration</p>
</li>
<li><p>@ComponentScan</p>
</li>
</ul>
<p>2, 其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。</p>
<p>​	内部就是读取了该项目和该项目引用的Jar包的的classpath路径下META-INF&#x2F;spring.factories文件中的所配置的类的全类名。 	在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。</p>
<p>3, 条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/" data-id="cltu174tc000r48nueu6qaif0" data-title="Spring.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/项目/mit824" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/mit824/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/mit824/">mit6.824.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>基于Raft协议实现的KV数据库，实现了数据的查询、存储和分布式的容错。在集群中的每个服务器由Raft节点和状态机组成，其中Raft节点是用来支持Raft协议来实现数据一致性，状态机用来存储数据。</p>
<h1 id="基本Java项目"><a href="#基本Java项目" class="headerlink" title="基本Java项目"></a>基本Java项目</h1><blockquote>
<p>idea解析不了java文件</p>
</blockquote>
<p>右键指定目录，在Mark Direction as 中将目录作为需要的目录。</p>
<p>删除.idea文件</p>
<p>在file-&gt;inviadate and restart处重启idea。</p>
<blockquote>
<p>如何引入依赖</p>
</blockquote>
<p>创建一个lib目录，将所需依赖的jar包放入lib目录。</p>
<p>在project struction中的library中将该目录下的jar包add进去</p>
<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>Raft结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        		 sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers     		 []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister 		 *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        		 <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead      		 <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line">	<span class="comment">//超时选举</span></span><br><span class="line">	currentTerm 	 <span class="type">int</span> <span class="comment">//最后一次收到的服务的任期</span></span><br><span class="line">	votedFor 		 <span class="type">int</span> <span class="comment">//在当前term下收到选举的candidateId</span></span><br><span class="line">	voteCount 		 <span class="type">int</span><span class="comment">//当前term收到的投票成功数</span></span><br><span class="line">	status 			 Status <span class="comment">//节点类型</span></span><br><span class="line">	overtime 		 time.Duration <span class="comment">//任期倒计时总长</span></span><br><span class="line">	timer    		 *time.Ticker <span class="comment">//实现倒计时功能</span></span><br><span class="line">	<span class="comment">//日志复制</span></span><br><span class="line">	logs 			 []LogEntry</span><br><span class="line">	commitIndex 	 <span class="type">int</span> <span class="comment">//通过对 matchIndex 排序找中位数的 index ，就是大多数节点都拥有的日志范围，将其设置为 commitIndex 。</span></span><br><span class="line">	lastApplied 	 <span class="type">int</span></span><br><span class="line">	nextIndex 		 []<span class="type">int</span> <span class="comment">//每个服务器占一个slot，是下一个心跳发送给Follower的index；是Leader对Follower同步的猜测</span></span><br><span class="line">	matchIndex 		 []<span class="type">int</span> <span class="comment">//记录Leader和对应Follower匹配的长度，元素的记录将要复制给机器的日志的索引;实际获知到的同步进度</span></span><br><span class="line">	applyChan 		 <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	<span class="comment">//日志快照</span></span><br><span class="line">	lastIncludeIndex <span class="type">int</span></span><br><span class="line">	lastIncludeTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab2A选举"><a href="#lab2A选举" class="headerlink" title="lab2A选举"></a>lab2A选举</h2><h3 id="超时选举概述"><a href="#超时选举概述" class="headerlink" title="超时选举概述"></a>超时选举概述</h3><p>raft为了满足其一致性，需要选出一个Leader。超时选举过程是每个节点都有一个自己的超时时间，如果在这段时间内没有收到心跳，就会触发超时选举，将自己变为Candidate，给其他节点发送投票请求，如果满足投票条件，其他节点会给自己投票，当自己票数过半且没有因为term过小或日志不满足要求等条件，该节点会变为Leader。为了防止多个节点同时发起投票产生平票等问题，Raft会给每个节点分配一个随机的选举超时时间（Election Timeout）。</p>
<h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>Node超过定时时间没有收到心跳，自己变为Candidate，发送选举请求，通过RPC调用其他Node的处理选举模块，下面是选举请求参数.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时选举</span></span><br><span class="line">Term 			<span class="type">int</span> <span class="comment">//candidate任期</span></span><br><span class="line">CandidateId 	<span class="type">int</span> <span class="comment">//candidate&#x27;s index in peers</span></span><br><span class="line"><span class="comment">//日志复制</span></span><br><span class="line">LastLogIndex 	<span class="type">int</span> <span class="comment">//最后一个日志的index</span></span><br><span class="line">LastLogTerm 	<span class="type">int</span>  <span class="comment">//最后一个日志的term</span></span><br></pre></td></tr></table></figure>

<p>被RPC调用的节点开始处理选举请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Candidate的term比自己小，或者自己已经投过票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt;= rf.currentTerm &#123;</span><br><span class="line">    拒绝投票并返回自己的任期以供Candidate更新</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修改自己的raft节点参数</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.如果Candidate的日志最后的term比自己的小</span></span><br><span class="line"><span class="comment">//2.最后日志的term相等，但是Candidate最后日志的index比自己的小</span></span><br><span class="line"><span class="comment">//拒绝投票</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(args.LastLogTerm &lt; rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term || (args.LastLogTerm ==  rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &lt; <span class="built_in">len</span>(rf.logs) + rf.lastIncludeIndex))&#123;</span><br><span class="line">    拒绝投票</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">投票并更新自己的超时时间，voteFor等参数</span><br></pre></td></tr></table></figure>

<p>Candidate来处理RPC调用结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Term 			<span class="type">int</span> <span class="comment">//给candidate发送自己的currentTerm，以便candidate更新自己的currentTerm</span></span><br><span class="line">VoteGranted 	<span class="type">bool</span> <span class="comment">//是否给candidate投票</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到之前请求的响应</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">    直接忽略</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理返回结果</span></span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123; <span class="comment">//给自己投票</span></span><br><span class="line">    <span class="keyword">if</span> rf.voteCount &lt;= <span class="built_in">len</span>(rf.peers) / <span class="number">2</span>&#123;</span><br><span class="line">        rf.voteCount++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rf.voteCount &gt; <span class="built_in">len</span>(rf.peers) / <span class="number">2</span>&#123;</span><br><span class="line">        <span class="number">1.</span>将投票数量变为<span class="number">0</span>，以保证投票的幂等性</span><br><span class="line">        <span class="number">2.</span>将自己的超时时间更新为心跳间隔，此后每隔一段时间发送一次心跳</span><br><span class="line">        <span class="number">3.</span>更新自己的状态为Leader     </span><br><span class="line">        <span class="number">4.</span>更新nextIndex和matchIndex，这是日志复制的核心</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;	<span class="comment">//拒绝给自己投票</span></span><br><span class="line">    更新任期，投票数量，voteFor等raft属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="心跳概述"><a href="#心跳概述" class="headerlink" title="心跳概述"></a>心跳概述</h3><p>Leader每个一段时间都会给其他节点发送一次心跳，使其他节点更新自己的超时时间，以保证其他节点不会竞争成为其他Leader。超时选举也算是心跳请求，也是使其他节点不能成为Leader，但是比较特殊的是自己要成为Leader。除此之外心跳还承担日志复制的责任，来使Follower和Leader的日志相同。</p>
<p>注意的是raft要满足心跳间隔&lt;选举定时，以保证Follower在选举定时到期之前收到心跳消息，避免不必要的选举；且满足RPC时间间隔 &lt; 心跳间隔，这样可以在下一个心跳间隔之前完成RPC请求处理。</p>
<h3 id="心跳过程"><a href="#心跳过程" class="headerlink" title="心跳过程"></a>心跳过程</h3><p>Leader每隔一段时间通过RPC给Follower发送一个心跳参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时选举</span></span><br><span class="line">LeaderId 		<span class="type">int</span></span><br><span class="line">Term 			<span class="type">int</span></span><br><span class="line"><span class="comment">//日志复制</span></span><br><span class="line">PreLogIndex 	<span class="type">int</span> <span class="comment">//前置日志索引，用来确定Follower从什么位置开始复制日志</span></span><br><span class="line">PreLogTerm 		<span class="type">int</span> <span class="comment">//前置日志任期，PreLogIndex处日志的任期，raft日志的特性可以根据term比较来知道日志是否相同</span></span><br><span class="line">Entries 		[]LogEntry <span class="comment">//Leader从PreLogIndex-1开始的日志</span></span><br><span class="line">LeaderCommit 	<span class="type">int</span> <span class="comment">//Leader的CommitIndex,来使Follower知道自己的日志该提交到哪</span></span><br></pre></td></tr></table></figure>

<p>Follower处理心跳请求（为了叙述简单，以下没有考虑Lab2D日志快照）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己的term比Leader的还大</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">    返回自己的term以更新Leader的term</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">更新term、选举定时等raft属性</span><br><span class="line"></span><br><span class="line"><span class="comment">//PreLogIndex比自己快照下标还考前</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex &lt; rf.lastIncludeIndex&#123;</span><br><span class="line">    让Leader更新自己对应的nextIndex为自己的快照下标   </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志冲突</span></span><br><span class="line"><span class="comment">//1. 假如没有快照时自己logs在preLogIndex处没有日志</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex &gt; rf.lastIncludeIndex &amp;&amp; args.PreLogIndex &gt; rf.lastIncludeIndex + <span class="built_in">len</span>(rf.logs)&#123;</span><br><span class="line">    让Leader更新自己对应的nextIndex为自己的日志长度</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.自己与Leader在preLogIndex处的日志不相同</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex &gt; rf.lastIncludeIndex &amp;&amp; rf.logs[args.PreLogIndex - rf.lastIncludeIndex - <span class="number">1</span>].Term != args.PreLogTerm&#123;</span><br><span class="line">   	让Leader使用二分法更新自己对应的nextIndex</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果携带着日志</span></span><br><span class="line"><span class="keyword">if</span> args.Entries != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(args.Entries) &gt; <span class="number">0</span>&#123;</span><br><span class="line">    从PreLogIndex处复制日志</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从自己的日志提交下标到Leader的日志提交下标，开始遍历</span><br><span class="line"><span class="number">1.</span>先使自己的日志提交下标+<span class="number">1</span></span><br><span class="line"><span class="number">2.</span>响应日志给状态机</span><br><span class="line"><span class="number">3.</span>更新自己日志响应下标为日志提交下标</span><br></pre></td></tr></table></figure>

<p>Leader处理RPC结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Success 		<span class="type">bool</span></span><br><span class="line">Term 			<span class="type">int</span></span><br><span class="line">NextIndex 		<span class="type">int</span> <span class="comment">//Leader的nextIndex对应slot的值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是之前RPC响应结果</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term || rf.status != Leader || rf.nextIndex[followerId] != args.PreLogIndex&#123;</span><br><span class="line">    直接忽略</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;<span class="comment">//返回失败</span></span><br><span class="line">    <span class="comment">//如果是日志复制失败</span></span><br><span class="line">    <span class="keyword">if</span>  rf.currentTerm == reply.Term&#123;</span><br><span class="line">        更新Follower对应nextIndex为，Follower响应的结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出现网络分区</span></span><br><span class="line">    更新term、变为Follower、将心跳间隔变为选举定时   </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//返回成功</span></span><br><span class="line">    更新nextIndex和matchIndex    </span><br><span class="line">    得到matchIndex的中位数，该中位数就是哪个最新的日志被大部分节点锁拥有，也就作为Leader的新的comitIndex</span><br><span class="line">    从自己的日志提交下标到新的的日志提交下标，开始遍历</span><br><span class="line">    <span class="number">1.</span>先使自己的日志提交下标+<span class="number">1</span></span><br><span class="line">    <span class="number">2.</span>响应日志给状态机</span><br><span class="line">    <span class="number">3.</span>更新自己日志响应下标为日志提交下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="加锁问题"><a href="#加锁问题" class="headerlink" title="加锁问题"></a>加锁问题</h3><blockquote>
<p>为什么需要加锁</p>
</blockquote>
<p>像处理选举，日志复制等操作都需要修改和使用到raft的属性。如果不加锁可能会发生线程不安全问题。</p>
<blockquote>
<p>加锁时出现的问题</p>
</blockquote>
<p>ticker函数类似于每个raft的主函数，在一个while true循环里等待心跳超时或选举超时，然后发送选举或心跳RPC，而RPC参数是要copy节点的属性，需要加锁。</p>
<p>本来是在想在while true循环里加锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.timer.C:</span><br><span class="line">        <span class="keyword">switch</span> rf.status&#123;</span><br><span class="line">            <span class="keyword">case</span> Follower:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Candidate:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Leader:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在每一次循环刚开始就加锁会发生下面情况：</p>
<p>每个节点都是刚创建好就进入ticker函数，一进循环就加锁，此时所有每个节点都拿着自己的锁。</p>
<p>当有一个节点变为Candidate发送请求选举的RPC，然后等待其他节点处理该请求，但是处理请求RPC也需要加锁，此时该节点就要等到自己发送了选举请求释放锁才能处理该请求。这会导致所有节点都堆积到自己变为Candidate后释放锁后处理别的节点的请求，又因为自己是Candidate不会给同term的其他Candidate投票，就不会出现任何一个过半票的节点。然后他们都又重新在一个新的term来进行选举，又因为以上原因循环往复导致无法选出Leader。</p>
<p>所以就需要修改加锁时机，不能一上来就加锁，这里改为了等到选举时间或心跳间隔时间一到，再加锁，然后发送请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.timer.C:</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">switch</span> rf.status&#123;</span><br><span class="line">            <span class="keyword">case</span> Follower:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Candidate:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Leader:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h3><blockquote>
<p>忽略之前RPC的返回值</p>
</blockquote>
<p>因为可能由于网络问题导致节点可能收到之前发送RPC的处理返回值，这时就需要将该返回值抛弃.</p>
<p>如：</p>
<p>1给2发送vote请求，2没来得及处理。但是1超过半票变为Leader，之后给2发送心跳，这时他俩的term就一样了。<br>此时2才来处理1的vote请求，给1的vote请求响应false。但是1还应该是Leader所以需要忽略该返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">   <span class="comment">//fmt.Println(&quot;收到之前vote的响应&quot;)</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否变为Leader</p>
</blockquote>
<p>Candidate需要判断自己票数是否过半来决定自己是否变为Leader，判断的时候不应该等到所有节点返回结果后统计决定是否变为Leader，而是一过半就变为Leader，因为那样会发生某个节点crash掉导致一直无法选出Leader。</p>
<h2 id="lab2B-日志复制"><a href="#lab2B-日志复制" class="headerlink" title="lab2B 日志复制"></a>lab2B 日志复制</h2><h3 id="日志复制概述"><a href="#日志复制概述" class="headerlink" title="日志复制概述"></a>日志复制概述</h3><p>一旦一个候选者成为 leader，它将开始处理客户端的请求。客户端的每个请求包含了一条需要执行到状态机的命令。leader 将命令追加到自己的日志记录，同时并发 AppendEntries RPCs 请求来进行日志复制。当日志安全的复制之后，leader 将日志应用到自己的状态机并将结果返回给客户端。</p>
<p>每条日志记录包含了leader 的任期和状态机命令。任期是为了检测日志之间的不一致：</p>
<p>• 如果两个日志的两条日志记录有相同的索引和任期，那么这两条日志记录中的命令必然也是相同的。<br>• 如果两个日志的两条日志记录有相同的索引和任期，那么这两个日志中的前继日志记录也是相同的。</p>
<p>因为如果两个日志的两条日志记录有相同的索引和任期证明他们此处及之前的日志记录都和Leader对应索引及之前的日志记录相同。</p>
<h3 id="选举部分"><a href="#选举部分" class="headerlink" title="选举部分"></a>选举部分</h3><ul>
<li><p>选举时选举出来的Leader必须是拥有所有已提交的日志</p>
</li>
<li><p>选举时，给Candidate投票的前提是：</p>
<p>• Candidate最后一个日志的term比自己最后一个日志的term大。（如果别人最后一个日志的term比自己的还大，证明别人最  </p>
<p>   后收到的消息的Leader比自己最后收到消息的Leader新，而新Leader比老Leader更全的已提交日志，复制给发送端的已提</p>
<p>   交日志比自己的更全，自己就要给它投票）</p>
<p>• 如果Candidate最后一个日志的term和自己的相同，但是其索引比自己的大。（最后一个日志的term相同说明都是由一个</p>
<p>  Leader复制的日志，而别人的日志长度更长说明别人别人之前收到Leader的日志更新，其比自己更有可能拥有所有已提交</p>
<p>  日志)</p>
</li>
</ul>
<blockquote>
<p>细节一</p>
</blockquote>
<p>在节点处理RPC请求逻辑中，本来是为了快速过滤掉不符合的选举请求，将所有不满足条件的请求直接返回flase。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Candidate的term比自己小，或者自己已经投过票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt;= rf.currentTerm &#123;</span><br><span class="line">    reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.如果Candidate的日志最后的term比自己的小</span></span><br><span class="line"><span class="comment">//2.最后日志的term相等，但是Candidate最后日志的index比自己的小</span></span><br><span class="line"><span class="comment">//拒绝投票</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(args.LastLogTerm &lt; rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term || (args.LastLogTerm ==  rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &lt; <span class="built_in">len</span>(rf.logs)))&#123;   </span><br><span class="line">    reply.VoteGranted = <span class="literal">false</span>   </span><br><span class="line">    reply.Term = args.Term</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.status = Follower</span><br><span class="line">rf.overtime = time.Duration(<span class="number">150</span>+rand.Intn(<span class="number">200</span>)) * time.Millisecond</span><br><span class="line">rf.timer.Reset(rf.overtime)</span><br></pre></td></tr></table></figure>

<p>在一般情况下可以正确运行，但是当大部分节点crash掉，然后重连后，会出现特例情况。</p>
<p>比如：</p>
<p>在重新选举时，失联节点会更新term但因为日志不满足条件而不能成为Leader，但是此时未失联节点的term比失联后重新选举的小，未crash节点也无法成为Leader。此时除非未crash节点的两次选举之间没有其他节点竞选，可能会因term更新选举上。</p>
<p>解决办法：</p>
<p>将节点currentTerm的更新放到任期判断逻辑前面，这样做有两个好处：</p>
<p>1.任期判断没有返回就说明其他节点的term已经比自身的term大，此时也应该即时的修改自身的term。</p>
<p>2.即使发生上面那种情况解决，未crash节点也能在因日志不满足返回前将自身的term即时更新为crash过的节点，这样等到自  	己选举时可以成功竞选上，以免浪费大量时间在选举上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Candidate的term比自己小，或者自己已经投过票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt;= rf.currentTerm &#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.status = Follower</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.如果Candidate的日志最后的term比自己的小</span></span><br><span class="line"><span class="comment">//2.最后日志的term相等，但是Candidate最后日志的index比自己的小</span></span><br><span class="line"><span class="comment">//拒绝投票</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(args.LastLogTerm &lt; rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term || (args.LastLogTerm ==  rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &lt; <span class="built_in">len</span>(rf.logs)))&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="心跳部分"><a href="#心跳部分" class="headerlink" title="心跳部分"></a>心跳部分</h3><blockquote>
<p>接收端任期更新细节</p>
</blockquote>
<p>心跳部分也要注意和选举部分细节一样的地方，而且还需额外更新当前节点的超时选举</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Leader的term比自己的还小</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.status = Follower</span><br><span class="line">rf.overtime = time.Duration(<span class="number">150</span>+rand.Intn(<span class="number">200</span>)) * time.Millisecond</span><br><span class="line">rf.timer.Reset(rf.overtime)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不满足日志赋值</span></span><br><span class="line"><span class="comment">//1.自己logs在preLogIndex处没有日志</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex != <span class="number">0</span> &amp;&amp; args.PreLogIndex &gt; <span class="built_in">len</span>(rf.logs)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.自己与Leader在preLogIndex处的日志不相同</span></span><br><span class="line"><span class="comment">//TODO 优化reply.NextIndex</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex != <span class="number">0</span> &amp;&amp; rf.logs[args.PreLogIndex - <span class="number">1</span>].Term != args.PreLogTerm&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果因为某种情况没有了Leader，而Follower的大部分日志都不相同，这时就需要大量的心跳来测试出PreLogIndex的大概位置。此时某个Follower选举上，nextIndex[i]都初始化为自己logs的长度，需要不断发送心跳来试每个Follower正确的PreLogIndex。而如果不把更新超时时间放在日志冲突判断前，此时若发生日志冲突但不会更新选举超时，而这样会导致在大量心跳测试PreLogIndex时Follower触发超时选举，term会增加，会使Leader变回Follower。但因为日志原因，最后原Leader会又变回Leader，但是nextIndex[i]有初始化为logs的长度。又发生上面情况，依次往复，一直不能完成日志复制。</p>
<p>而这样做也符合要求，Follower接收到比自己term大的Leader的心跳，就会更新超时选举，即使日志不能匹配，也只是返回自己期望的下一个PreLogIndex。</p>
<blockquote>
<p>发送端过滤之前心跳</p>
</blockquote>
<p>在2A处心跳只是用来更新超时选举和更正Leader任期，只需过滤掉之前任期的心跳，即使是当前任期之前发送的其他心跳，也没有必要过滤。</p>
<p>但是添加了日志复制，如果不过滤当前任期之前的心跳，可能会导致下面使nextIndex回退，一直匹配不上期望的nextIndex。</p>
<p>选举的话，每一次选举就会让term增加，只需判断rf.currentTerm和args.term就可以过滤之前的选举。而过滤当前term之前发送的心跳就需要用rf.nextIndex[followerId] 和 args.PreLogIndex比较，因为每一次心跳都会导致nextIndex向前匹配，而PreLogIndex值和nextIndex一样，如果它两不相等就是之前发送的心跳。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term || rf.status != Leader || rf.nextIndex[followerId] != args.PreLogIndex&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">    <span class="comment">//日志复制失败</span></span><br><span class="line">    <span class="keyword">if</span>  rf.currentTerm == reply.Term&#123;</span><br><span class="line">        <span class="comment">//如果前面不加rf.nextIndex[followerId] != args.PreLogIndex判断就可能发生下面情况：</span></span><br><span class="line">        <span class="comment">//几次心跳已经让nextIndex向前匹配期望nextIndex，但是接收到当前term的之前发送的心跳，使得nextIndex又回退</span></span><br><span class="line">        rf.nextIndex[followerId] = reply.NextIndex       </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出现网络分区</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="响应消息给状态机"><a href="#响应消息给状态机" class="headerlink" title="响应消息给状态机"></a>响应消息给状态机</h3><p>在SendAppenEntires和AppenEntires中当满足一些条件时生成响应消息通过channel给状态机，而方法中开始就用Lock和defer UnLock，但是如果channel阻塞住，就会一直不释放锁，所以需要将响应消息放到锁区间外面。</p>
<h2 id="Lab2C持久化"><a href="#Lab2C持久化" class="headerlink" title="Lab2C持久化"></a>Lab2C持久化</h2><p>持久化主要持久化以下属性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rf.currentTerm <span class="comment">//持久化该属性是为了在选举或心跳时，知道自己的term来处理RPC携带的term</span></span><br><span class="line">rf.votedFor	<span class="comment">//持久化该属性是为了避免重启后，自己之前给term中某个节点投过票，不持久化的话，会再给其他节点投票，发生				半票等情况</span></span><br><span class="line">rf.logs </span><br><span class="line">rf.lastIncludeIndex <span class="comment">//持久化该属性是为了知道自己从哪个索引进行的日志快照，如果不持久化的话，在日志快照部分会有许多					下标问题</span></span><br><span class="line">rf.lastIncludeTerm <span class="comment">//持久化该属性是为了在加了日志快照模块后，正确处理心跳</span></span><br></pre></td></tr></table></figure>

<p>其他属性都可以通过再次选举得到，比如commitIndex，raft通过持久化恢复后可以通过不断的心跳得到原来的commitIndex。</p>
<h2 id="Lab2D日志快照"><a href="#Lab2D日志快照" class="headerlink" title="Lab2D日志快照"></a>Lab2D日志快照</h2><p>日志快照主要是引入了lastIncludeIndex和lasstIncludeTerm两个属性，但是需要将原来代码关于下标部分全部进行修改，否则会出现下标问题，如数组越界，在ticker函数情况考虑不全没有发送任何RPC导致一直选举等问题。</p>
<h1 id="KV数据库"><a href="#KV数据库" class="headerlink" title="KV数据库"></a>KV数据库</h1><h2 id="Lab3A-client和server"><a href="#Lab3A-client和server" class="headerlink" title="Lab3A client和server"></a>Lab3A client和server</h2><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>一开始，Client 并不知道 Leader Server 是哪台 Server。Client 可向随机一台 Server 发送 RPC 请求。假如请求的 Server 不是当前的 Leader Server，或者由于网络中断、Server Crash 等原因，无法与 Server 取得联系，则无限地尝试更换 Server 重新发送请求，直到请求成功被处理。在得知 Leader Server 后，Client 保存 Leader 的 id，避免下次发起请求时又需要随机地选择一台 Server 多次尝试。</p>
<p>Client 发送的请求 Server 成功接收，Server 也将请求中的 command 成功在 Raft 层达成共识并应用至状态机，然而在回复 Client 时出现了问题，RPC 回复丢失。这样就有可能导致一次请求多次重复提交的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">	servers []*labrpc.ClientEnd</span><br><span class="line">	<span class="comment">// You will have to modify this struct.</span></span><br><span class="line">	seqId <span class="type">int64</span></span><br><span class="line">	leaderId <span class="type">int</span></span><br><span class="line">	clientId <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server在接收到 Client 的请求后，通过调用 <code>raft.Start()</code> 将请求包含的 command 传递到 Raft 层，达成共识。</p>
<ul>
<li>Raft 层达成共识后，通过 applyCh 通知 Server 该 command 已达成共识，然后Server返回给Client。</li>
<li>如果当前 Server 不为 Leader，则向 Client 返回错误，Client 在收到回复后重新尝试向另一台 Server 发起请求。</li>
</ul>
<p>但如果有多个 Client 并行地调用Server，因为在raft层不知道放入applyCh命令的顺序，Server层也就不能保证从 applyCh 每次取出的结果与期望的Client对应。为了解决这个问题，需要细化给Client返回的结果是从什么中获取，这里想的是建立一个commandIndex和新建channel的映射。当命令进入Raft层时就会返回给Server对应的CommandIndex，因为Raft的Start方法是同步方法，每个CommandIndex都不同，在Server的方法中就能用CommandIndex来区分每一个Client的调用，Raft达成共识后Server从响应结果就知道是哪个CommandIndex对应的结果，然后从映射中获取到对应的channel来响应对应的Client。</p>
<p>如果 Raft 层长时间无法完成共识 (由于网络分区等原因)，不要让 Server 一直阻塞。及时向 Client 返回 Timeout 错误，使其重新选择另一台 Server 重试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      <span class="type">int</span></span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">	applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">	dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">	maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	kvPersist <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> <span class="comment">//持久化key/value对</span></span><br><span class="line">	waitChMap <span class="keyword">map</span>[<span class="type">int</span>] <span class="keyword">chan</span> Op <span class="comment">//上面解释了</span></span><br><span class="line">	maxSeq <span class="keyword">map</span>[<span class="type">int64</span>] <span class="type">int64</span> <span class="comment">//fault-tolerant最后一个点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fault-tolerant"><a href="#fault-tolerant" class="headerlink" title="fault-tolerant"></a>fault-tolerant</h3><p>可能出现的fault：</p>
<ul>
<li>Client给Server发送RPC，因某些原因Server未收到。<ul>
<li>让Client慢慢给其他Server发送RPC重试</li>
</ul>
</li>
<li>Server调用Raft的Start方法添加日志失败<ul>
<li>不断重试调用Start方法</li>
</ul>
</li>
<li>Raft达成共识了，但是给Server返回时出现问题<ul>
<li><strong>先将封装的结果返回，再增加节点的lastApplied</strong>，这样如果给Server返回失败，在以后某个时刻节点从lastApplied也知道应该将该结果返回</li>
</ul>
</li>
<li>Server收到Raft的结果，但是并没有来得及执行命令，导致命令多次被Raft共识。<ul>
<li>？Raft对SeqId也进行去重</li>
</ul>
</li>
<li>Server执行了命令，但是没有来得及返回给Client，Client会不断重试导致命令被多次执行。<ul>
<li>问题是一个命令会被多次执行，Raft只管日志共识，并不用管日志是否重复被共识，所以需要由Client和Server来保证。Client创建时建立一个属性SeqId，每当一个命令被Server执行就自增SeqId，Server建立一个ClientId和SeqId的映射，每次在Raft响应后通过maxSeq[ClientId]&lt;SeqId，如果不满足就证明该命令已被执行过，不再执行，直接返回给Client。（<strong>值的注意的是</strong>：判断和修改maxSeq[ClientId]的时机，需要<strong>等到Server收到Raft共识后的响应时才能才操作maxSeq</strong>。因为如果命令执行后，Leader又换为其他Server，Client也会转向变为Leader的Server发送命令，但此时该Server的maxSeq并没有更新，又触发Raft共识操作，相当于命令被执行了两次。而在Server接收到Raft共识后操作，会因为Raft共识后会给那些日志复制成功的Server响应，而他们的maxSeq也被修改了，并且新的Leader只会从他们中选举出来）</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E9%A1%B9%E7%9B%AE/mit824/" data-id="cltu174th001p48nu34wva9vn" data-title="mit6.824.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/项目/点评" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E7%82%B9%E8%AF%84/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E7%82%B9%E8%AF%84/">点评.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="各个模块"><a href="#各个模块" class="headerlink" title="各个模块"></a>各个模块</h1><h2 id="博客模块"><a href="#博客模块" class="headerlink" title="博客模块"></a>博客模块</h2><ul>
<li><p>添加博客</p>
<p>&#x2F;&#x2F;TODO 推送</p>
<p><code> 添加博客之后还需要查询tb_follow表来查询该用户的所有粉丝并且使用feed流给每位粉丝推送</code></p>
</li>
<li><p>查看部分博客</p>
<ul>
<li>滚动分页查询  —–&gt; 返回结果中有下一次查询起始位置的id,等到下一次查询的时候带上该id。</li>
<li>需要关联查询来给Blog类的isLiked字段赋值</li>
<li>查询博客时，使用关联查询将作者信息封装到Blog对象，而不是两次查询使用stream流将每个用户封装到Blog对象，减少应用层和数据层交互</li>
</ul>
</li>
<li><p>博客评论</p>
<p>在博客表中博客和评论在同一张表中，根据parent_id字段区别，如果为0则为博客，为其他值则为评论的博客id</p>
</li>
<li><p>给博客点赞</p>
<p><code>刚开始用户查看博客时将用户已经点赞的博客的isLike字段(tb_blog不存在该字段)赋值为true,之后前端一直存储该字段，并且根据该字段来在请求头上提示后端用户是选择点赞还是取消点赞。后端操作用户点赞功能通过修改redis的“blog：liked：”+blog_id（set类型，存储之前没有点赞过的选择点赞）添加userId存储点赞用户，以及“blog：unliked：”+blog_id（set，存储之前点赞过的，选择取消点赞）添加userId存储取消点赞用户，以给前端快速的响应时间。比如开始点赞，如果“blog：unliked：”+blog_id没有userId（说明之前没有点过赞，因为之前点过赞还使该set为空说明上一步是点赞操作，那么这一步是取消点赞操作不符合用户选择点赞操作），向“blog：liked：”+blog_id添加userId，取消点赞因为“blog：liked：”+blog_id有userId，所以移除set中的userId。后端使用定时任务每两分钟将点赞userId和取消点赞userId存储到数据库（只需插入“blog：liked：”+blog_id中的userId和blogId的记录，删除“blog：unliked：”+blog_id中的userId和blogId的记录）,并清空redis中的点赞与取消点赞信息（之后前端都是根据前端本地存储来显示用户是否已经点赞并给后端提示相应的信息，但是如果用户使用抓包软件修改就会导致某个博客每半个小时就能再点赞一次，要解决这个问题就需要前端和后端协商好将url中的数据按一定格式设置复杂）</code></p>
</li>
</ul>
<h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><p>用户基本信息表ums_member</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本信息</span></span><br><span class="line"><span class="built_in">id</span> <span class="comment">#用户Id</span></span><br><span class="line">level <span class="comment">#用户等级</span></span><br><span class="line">header<span class="comment">#用户头像</span></span><br><span class="line">gender<span class="comment">#用户性别</span></span><br><span class="line">birth<span class="comment">#用户生日</span></span><br><span class="line">college<span class="comment">#用户学院</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录信息</span></span><br><span class="line">username <span class="comment">#用户名</span></span><br><span class="line">password <span class="comment">#密码 MD5加密</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用于验证用户身份，目前只实现了邮箱验证</span></span><br><span class="line">mobile <span class="comment">#手机</span></span><br><span class="line">email <span class="comment">#邮箱</span></span><br></pre></td></tr></table></figure>

<p>用户收货地址表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span></span><br><span class="line">member_id <span class="comment">#关联用户表中的用户id</span></span><br><span class="line">name <span class="comment">#收货昵称</span></span><br><span class="line">phone <span class="comment">#收货使用手机号码</span></span><br><span class="line">detail_address <span class="comment">#详细地址</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>如何实现的MD5盐加密及验证</p>
</blockquote>
<p>通过使用java.security中的MessageDigest.getInstance(“MD5”).digest(“字符串”);</p>
<p>实现MD5加密，但是MD5容易破解，就需要在字符串上拼接一段难以破解的字符串，在进行MD5加密，实现MD5盐加密。</p>
<blockquote>
<p>如何实现的邮箱验证</p>
</blockquote>
<blockquote>
<p>如何实现n台设备同时登录</p>
</blockquote>
<blockquote>
<p>如何实现同一时间只能有一个设备登录</p>
</blockquote>
<blockquote>
<p>登录时存在什么问题</p>
</blockquote>
<ul>
<li><p>登录功能<br> <code>通过过滤器链来进行刷新在线时间以及拦截需要登陆才能访问的模块，因为刷新在线时间是只要发送请求就能刷新在线时间，那么刷新在线时间拦截器是拦截所有请求，来在拦截器中操作；而拦截需要登陆模块的拦截器拦截除了登录、注册、看博客、看商品等请求之外的所有请求；将两个过滤器谁前谁后都可以。</code></p>
</li>
<li><p>注册功能</p>
</li>
</ul>
<p><strong>登录需要到数据库查找判断信息是否正确，这里会存在缓存穿透问题，这里使用缓存空对象的方法解决该问题</strong></p>
<h2 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h2><p>订单表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#订单基本信息</span></span><br><span class="line"><span class="built_in">id</span> </span><br><span class="line">order_sn <span class="comment">#订单号</span></span><br><span class="line">member_id <span class="comment">#用户id</span></span><br><span class="line">coupon_id <span class="comment">#优惠卷id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#订单展示信息</span></span><br><span class="line">member_username<span class="comment">#用户名</span></span><br><span class="line">receiver_name <span class="comment">#收件人姓名</span></span><br><span class="line">receiver_phone <span class="comment">#收件人手机号</span></span><br><span class="line">receiver_email <span class="comment">#收件人邮箱</span></span><br><span class="line">receiver_detail_address <span class="comment">#收件人地址</span></span><br><span class="line">status <span class="comment">#订单状态【0-&gt;待付款；1-&gt;已付款，但未发货；2-&gt;已发货；3-&gt;已完成；4-&gt;已关闭；5-&gt;已取消】</span></span><br><span class="line">create_time <span class="comment">#订单创建时间</span></span><br><span class="line">pay_time <span class="comment">#支付时间</span></span><br><span class="line">total_amount<span class="comment">#总价</span></span><br><span class="line">pay_amount<span class="comment">#实际支付价格</span></span><br></pre></td></tr></table></figure>

<p>订单项目表（每创建一个订单后，该订单中包含了几种商品，就需要在订单项目表中，增加几条记录；）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span></span><br><span class="line">order_sn <span class="comment">#关联的订单号</span></span><br><span class="line">spu_id <span class="comment">#spuid</span></span><br><span class="line">spu_name <span class="comment">#spuName</span></span><br><span class="line">sku_id <span class="comment">#skuId</span></span><br><span class="line">sku_name <span class="comment">#skuName</span></span><br><span class="line">sku_pic <span class="comment">#sku图片</span></span><br><span class="line">sku_price <span class="comment">#sku价格</span></span><br><span class="line">promotion_amount <span class="comment">#商品数量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>订单号如何生成</p>
</blockquote>
<blockquote>
<p>订单流程</p>
</blockquote>
<ul>
<li><p>创建订单</p>
<p>用户需要填写表单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receiver_name <span class="comment">#收件人姓名</span></span><br><span class="line">receiver_phone <span class="comment">#收件人手机号</span></span><br><span class="line">receiver_email <span class="comment">#收件人邮箱</span></span><br><span class="line">receiver_detail_address <span class="comment">#收件人地址</span></span><br></pre></td></tr></table></figure>

<p>前端Post请求携带参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">coupon_id <span class="comment">#优惠卷id</span></span><br><span class="line">receiver_name <span class="comment">#收件人姓名</span></span><br><span class="line">receiver_phone <span class="comment">#收件人手机号</span></span><br><span class="line">receiver_email <span class="comment">#收件人邮箱</span></span><br><span class="line">receiver_detail_address <span class="comment">#收件人地址</span></span><br><span class="line">sku_id <span class="comment">#skuId</span></span><br><span class="line">promotion_amount <span class="comment">#商品数量</span></span><br></pre></td></tr></table></figure>

<p>后端操作</p>
<p>1.拦截器从cookie获取memberId。</p>
<p>2.CompletableFuture+线程池获取用户信息，优惠卷信息，商品信息。</p>
<p>3.生成订单号，计算价格、时间等属性。</p>
<p>4.给前端返回订单号。</p>
</li>
<li><p>订单详情</p>
<p>前端Get请求携带参数订单号</p>
<p>后端返回订单详情（订单类里有一个订单Item的List集合）</p>
</li>
<li><p>取消订单</p>
<p>前端Post请求携带参数订单号</p>
<p>后端修改订单状态。</p>
</li>
<li><p>支付订单</p>
<p><em>见支付功能</em></p>
</li>
<li><p>订单列表</p>
<p>前端Get请求携带页号</p>
<p>后端获取用户Id，分页查询该用户所有订单，返回订单详情（订单类里有一个订单Item的List集合）</p>
</li>
</ul>
<blockquote>
<p>订单状态转变</p>
</blockquote>
<p>创建订单，订单变为<strong>未支付</strong>状态。</p>
<p>启动一个定时任务，30min内用户支付后，变为<strong>已支付</strong>状态；如果30min后未支付，变为<strong>已关闭</strong>状态。</p>
<p>商品发货后，变为<strong>已发货</strong>状态。</p>
<p>用户取消订单，变为<strong>已取消</strong>状态。</p>
<blockquote>
<p>订单号如何生成？</p>
</blockquote>
<p>订单号生成有雪花算法、UUID、Redisson生成等方法生成订单号。</p>
<p>这里用的是雪花算法。</p>
<p>雪花算法是生成一个64bit的序列化，其中包括时间戳、数据中心id、机器id、序列号。</p>
<p>序列号是用来分辨同一时间戳下不同的订单号。</p>
<p>自定义的订单号生成工具类是将存储long类型的时间戳、数据中心id、机器id、上次调用的时间戳（用来将序列号归0）。</p>
<p>并在同一时间戳下使用同一个AutomicInteger的序列号原子自增。</p>
<p>最后使用各部分左移和或运算符生成序列号。</p>
<h3 id="优惠卷功能"><a href="#优惠卷功能" class="headerlink" title="优惠卷功能"></a>优惠卷功能</h3><p>优惠卷表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span></span><br><span class="line">shop_id <span class="comment">#商铺id</span></span><br><span class="line">title <span class="comment">#优惠卷标题</span></span><br><span class="line">sub_title <span class="comment">#副标题</span></span><br><span class="line">rules <span class="comment">#使用规则</span></span><br><span class="line">pay_value <span class="comment">#支付金额</span></span><br><span class="line">actual_value <span class="comment">#抵消金额</span></span><br><span class="line"><span class="built_in">type</span> <span class="comment">#类型【0,普通券；1,秒杀券】</span></span><br><span class="line">status <span class="comment"># 状态【1,上架; 2,下架; 3,过期】</span></span><br><span class="line">create_time<span class="comment"># 创建时间</span></span><br><span class="line">update_time <span class="comment"># 更新时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>秒杀卷表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">voucher_id <span class="comment">#关联优惠卷id</span></span><br><span class="line">stock <span class="comment">#库存</span></span><br><span class="line">begin_time<span class="comment">#开始时间</span></span><br><span class="line">end_time<span class="comment">#结束时间</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>添加普通优惠卷</p>
</li>
<li><p>添加秒杀卷</p>
<p><code>将秒杀卷的优惠卷公用字段save到优惠卷表，将秒杀卷特有字段save到秒杀卷表。</code></p>
</li>
<li><p>展示指定店铺的优惠卷</p>
<p><code>查询店铺优惠卷，使用stream流将秒杀卷字段添加到优惠卷对象</code></p>
</li>
<li><p>秒杀卷获取功能</p>
<p><code> 使用lua脚本实现redis中原子的完成检查库存充足、一人一单（“voucher：belong：”+voucherId，set类型）、扣减库存；之后生成用户获取优惠卷的订单并加入阻塞队列，直接返回，而线程池使用使用其他线程异步完成订单到数据库的保存,提高系统响应速度。</code></p>
</li>
</ul>
<h3 id="支付功能"><a href="#支付功能" class="headerlink" title="支付功能"></a>支付功能</h3><h4 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h4><p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E7%82%B9%E8%AF%84/image-20240102184103627.png" alt="image-20240102184103627"></p>
<p>要实现支付宝支付需要又四把钥匙，商户私钥、商户公钥、支付宝私钥、支付宝公钥</p>
<blockquote>
<p>为什么需要商户公私钥，只用支付宝公私钥不行吗</p>
</blockquote>
<p>因为支付宝公钥都可以获取，如果只是用支付宝公私钥，别人就可以伪造一个支付请求。所以需要商户公私钥，私钥保存在服务器，公钥上传到支付宝，别人就不能伪造支付请求。</p>
<blockquote>
<p>向支付宝发送请求需要携带什么</p>
</blockquote>
<p>主要修改以下参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">APPID</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">RSA_PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//生成私钥，并把公钥上传给支付宝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">notify_url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//支付成功后，支付宝每隔一段时间就会发送通知，服务器就可以来修改订单状态等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">return_url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//支付成功要跳转的页面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ALIPAY_PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//配置支付宝返回的公钥</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编写流程</p>
</blockquote>
<p>引入依赖alipay-sdk-java</p>
<p>创建对应的AlipayClient和AlipayRequest</p>
<p>返回一个html字符串，让浏览器跳转<strong>支付页面</strong>。</p>
<p>用户支付成功后跳转到<strong>跳转页面</strong>，支付宝也会<strong>异步通知</strong>服务器，然后服务端修改订单状态。</p>
<h2 id="客服功能"><a href="#客服功能" class="headerlink" title="客服功能"></a>客服功能</h2><p>基于websocket实现,前端发送可以转为History类型的json，后端通过一个存储用户id与用户session之间映射的map判断用户是否在线，如果用户不在线，讲history对象的state属性置为0，若在线置为1并通过ws发送给接收方。然后把history对象存储到redis的一个list集合，每3秒的所有history都会存到同一个list里面。服务端开启定时任务，定时任务会获取前三秒存储到redis的单聊history存储到数据库并删除该list。</p>
<h3 id="前缀树敏感词脱敏"><a href="#前缀树敏感词脱敏" class="headerlink" title="前缀树敏感词脱敏"></a>前缀树敏感词脱敏</h3><p>构建前缀树是放到静态代码块中，在项目根目录下放着一个记录好的敏感词文本文件，在静态代码块中通过这个文本文件来构造前缀树。</p>
<p>敏感词脱敏是使用三个指针，一个指向前缀树，其他两个是用于使用双指针法来查找敏感词的。具体过程为，指针1一直指向前缀树的根节点，指针2和指针3在没有找到疑似敏感词时时一起移动的。当指针2指向的文字在指针1的某个字点中,就为疑似找到敏感词，指针2就一直指向该处作为疑似敏感词的头指针，临时指针指向前缀树中被匹配的节点，指针3一直向后查找，直到确认该词为敏感词，就将指针2与指针3之间的文本全部替换为*号.</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E7%82%B9%E8%AF%84/20200423103755739.png" alt="在这里插入图片描述"></p>
<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ul>
<li><p>配置类</p>
<p>WebSocketConfigurer接口：registerWebSockethandlers()方法，将路径和处理器映射。</p>
</li>
<li><p>自动配置类</p>
<p>spring-boot-autoconfigure依赖下websocket目录有</p>
<p>WebSocketMessagingAutoConfiguration</p>
<p>WebSocketServletAutoConfiguration</p>
<p>WebSocketReactiveAutoConfiguration</p>
</li>
<li><p>核心类</p>
<p>WebSocketSession接口</p>
<p>WebSocketHandler接口</p>
<p>WebSocketMessage接口</p>
</li>
</ul>
<h3 id="使用websocket时的问题"><a href="#使用websocket时的问题" class="headerlink" title="使用websocket时的问题"></a>使用websocket时的问题</h3><p>主要有Bean注入和无法获取principal</p>
<blockquote>
<p>原生websocket，使用到原生注解如@OnOpen等注解的对象使用@Autowired注解自动装配Bean时，出现null异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChatService chatService;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>WebSocket 是多实例单线程的。每当有新的 WebSocket 连接建立时，都会创建一个新的 WebSocket 实例。这些新的 WebSocket 实例需要访问 Spring 容器中的 Bean。</p>
<p>问题就在于，如果在 WebSocket 实例中使用 <code>@Autowired</code> 注解来注入 Spring 容器中的 Bean，那么只有在整个应用程序启动时，Spring 容器才会创建一个 Bean 实例并将其注入到 WebSocket 实例中。而对于之后创建的新的 WebSocket 实例，Spring 容器不会再次创建和注入新的 Bean 实例。因此，这些新的 WebSocket 实例中的 <code>@Autowired</code> 注解的 Bean 将会是 null。</p>
<p><strong>解决办法：</strong></p>
<p>1.使用 <code>prototype</code> 作用域来声明需要注入到 WebSocket 中的 Bean。<code>prototype</code> 作用域的 Bean 在每次使用时都会创建一个新的实例。这样在新的 WebSocket 实例创建时，就会创建一个新的 Bean 实例并注入到 WebSocket 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.还是使用单例Bean，但是将该对象用static修饰，在Spring容器启动时就给该静态对象赋值。—-<strong>使用的是该方法解决的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChatService</span><span class="params">(ChatService chat)</span> &#123;</span><br><span class="line">        ChatController.chatService = chat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChatService chatService;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无法获取到principal</p>
</blockquote>
<p><strong>问题</strong></p>
<p>想在WebSoketSession连接建立时获取到principal，并建立用户与WebSocketSession映射。跟踪WebSocketSession建立，知道principal是在SecurityContext得到。但是不管是在登陆后将Authentication放入SecurityContext还是debug模式下在协议升级时将Authentication放入SecurityContext都无法在WebSocketSession中得到。</p>
<p><strong>原因</strong></p>
<p>WebSocket协议本质上是一种无状态的通信协议，与HTTP不同，它不维护会话（Session）状态。每个WebSocket连接都是独立的，不会自动与HTTP会话相关联。</p>
<p><strong>解决</strong></p>
<p>用户登录后，用户信息会返回给前端，在websocket连接url上携带着用户id，然后在websocket连接建立时建立映射。</p>
<p><strong>跟踪WebSocketSession给userPrincipal赋值</strong></p>
<ul>
<li><p>通过继承AbstractWebSocketHandler的handler的afterConnectionEstablished方法，知道afterConnectionEstablished方法的参数是</p>
<p>StandardWebSocketSession类的对象</p>
</li>
<li><p>通过StandardWebSocketSession类的initializeNativeSession方法,跟踪到userPrincipal是由WsSession的getUserPrincipal方法赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeNativeSession</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>.user = session.getUserPrincipal();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给WsSession的构造方法断点，并根据栈信息知道是由WsHttpUpgradeHandler的init方法来创建的WsSession对象，执行构造方法传递的参数是由属性handshakeRequest的getUserPrincipal方法赋值的，handshakeRequest是在preInit方法赋值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(WebConnection connection)</span> &#123;</span><br><span class="line">       ....</span><br><span class="line">           wsSession = <span class="keyword">new</span> <span class="title class_">WsSession</span>(wsRemoteEndpointServer,</span><br><span class="line">                   webSocketContainer, handshakeRequest.getRequestURI(),</span><br><span class="line">                   handshakeRequest.getParameterMap(),</span><br><span class="line">                   handshakeRequest.getQueryString(),</span><br><span class="line">                   handshakeRequest.getUserPrincipal(), httpSessionId,</span><br><span class="line">                   negotiatedExtensions, subProtocol, pathParameters, secure,</span><br><span class="line">                   serverEndpointConfig);</span><br><span class="line">           </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInit</span><span class="params">(ServerEndpointConfig serverEndpointConfig,</span></span><br><span class="line"><span class="params">           WsServerContainer wsc, WsHandshakeRequest handshakeRequest,</span></span><br><span class="line"><span class="params">           List&lt;Extension&gt; negotiatedExtensionsPhase2, String subProtocol,</span></span><br><span class="line"><span class="params">           Transformation transformation, Map&lt;String,String&gt; pathParameters,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> secure)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="built_in">this</span>.handshakeRequest = handshakeRequest;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>handshakeRequest</strong>的getUserPrincipal是由构造方法的HttpServletRequest的getUserPrincipal结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Principal <span class="title function_">getUserPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> userPrincipal;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WsHandshakeRequest</span><span class="params">(HttpServletRequest request, Map&lt;String,String&gt; pathParams)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">       userPrincipal = request.getUserPrincipal();</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>这里需要知道给priInit方法的handshakeRequest是哪个实现类，通过给preInit方法断点，并根据栈信息跟踪到UpgradeUtil的doUpgrade和WsServerContainer的doUpgrade方法可知传递的是具体实现类是SecurityContextHolderAwareRequestWrapper，而SecurityContextHolderAwareRequestWrapper的getUserPrincipal方法是从SpringSecurity中获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Authentication <span class="title function_">getAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="keyword">return</span> (!<span class="built_in">this</span>.trustResolver.isAnonymous(auth)) ? auth : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：userPrincipal是通过HandShakeRequest，WsSession，StandardWebSocketSession依次传递的，而HadShakeRequest实现类获取userPrincipal是通过SecurityContext获取到的。</p>
</li>
</ul>
<h1 id="简历上内容"><a href="#简历上内容" class="headerlink" title="简历上内容"></a>简历上内容</h1><ol>
<li><p>登录模块中String的intern方法</p>
<blockquote>
<p>为什么要用intern方法</p>
</blockquote>
<p>项目让用户登录时同一时间只允许登录一次，可以使用乐观锁，如“update state &#x3D; 1 where username &#x3D; ‘xxx’ and state &#x3D; 0”，但是这样会导致如果同一时间大量请求用同一账号登录导致所有请求打到数据库，所以可以使用redis将已登录用户缓存起来。但是从redis判断用户是否登录以及更新用户登陆状态是两步操作，会有并发问题。所以需要使用悲观锁，但是如果锁住同一对象，会导致其他账号同一时间无法登录。而这里是要求保证同时间同一账号只能登录一次，所以可以以用户名作为区分度来降低锁的颗粒度，而不同请求的虽然用户名相同，但是用户名并不是同一个字符串对象，这里就需要用字符串的intern方法。</p>
<blockquote>
<p>介绍一下String的intern方法</p>
</blockquote>
<p>当我们调用intern()方法时，如果常量池中已经存在该字符串对象，则直接返回常量池中的字符串对象的引用；否则，在常量池中创建一个新的字符串对象，并返回该对象的引用。</p>
<p><a href="%5B(20%E6%9D%A1%E6%B6%88%E6%81%AF">详细过程</a> Java–深入理解字符串的String#intern()方法奥妙之处_吾日三省贾斯汀的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/JustinQin/article/details/120606343">https://blog.csdn.net/JustinQin/article/details/120606343</a>))</p>
<p>修正:<strong>字符串常量池中一直保存的都是字符串值</strong></p>
</li>
<li><p>ThreadLocal同一用户不同模块通信</p>
<blockquote>
<p>为什么用ThreadLocal</p>
</blockquote>
<p>因为SpringBoot每一个HTTP请求由一个独立线程处理，当使用到同一线程所有模块都可能用到但是每个线程又不相同的数据，就可以使用ThreadLocal来实现。</p>
<blockquote>
<p>为什么springboot中一个http请求由一个独立的线程处理</p>
</blockquote>
<p>在Spring Boot中，一个Web请求可以看作是一个线程，是因为Spring Boot使用了Servlet容器。Servlet容器在接收到一个HTTP请求时，会为该请求创建一个独立的线程来进行处理。这个线程在处理完请求之后就会被销毁，从而释放资源。</p>
<p>这个线程会负责处理请求中的所有操作，包括解析请求参数、执行业务逻辑、生成响应等。由于每个请求都会被分配到一个独立的线程中进行处理，所以不同的请求之间不会相互干扰，从而提高了系统的并发处理能力，还可以保证系统的稳定性和安全。</p>
<blockquote>
<p>ThreadLocal细节</p>
</blockquote>
<p><a href="D:\用户\Desktop\找offer\note\JUC\ThreadLocal.md">ThreadLocal细节</a></p>
<blockquote>
<p>哪个模块用到了ThreadLocal进行通信</p>
</blockquote>
<p>所有模块可能都会用到用户信息，所以在拦截器中将用户信息保存到对应的线程（在用户登陆的时候就把信息存储到redis中，拦截器中只需根据请求携带的token就可以获取到UserDto），等到其他模块使用的时候就可以从中获取（比如关注、点赞、获取优惠卷等都需要用户Id，用户Id就是根据线程中的ThreadLocalMap获取到的）。</p>
</li>
</ol>
<p>3.自编写缓存击穿，缓存穿透工具类</p>
<blockquote>
<p>哪些模块存在缓存穿透问题</p>
</blockquote>
<p>未注册用户登录、查找不存在店铺、获取不存在优惠卷、给不存在用户点赞等操作redis和数据库中都不存在的数据。</p>
<p>解决：使用缓存空对象解决的</p>
<blockquote>
<p>哪些模块存在缓存击穿问题</p>
</blockquote>
<p>某个秒杀卷过期</p>
<p>工具类中有互斥完成Redis数据更新，和返回过期数据。这里一般肯定会保证秒杀卷在redis不会过期，但是这里出现缓存击穿，那么有可能是由于其他模块错误操作导致数据误删除，就不能使用返回过期数据实现，这里使用的是互斥完成数据缓存。</p>
<p>5.lua脚本完成库存，一人一单，扣减库存原子性</p>
<p>先在静态代码块中给DefaultRedisScript对象初始化，再在具体实例方法中获取到参数执行lua脚本。</p>
<p>查看库存——-&gt;判断是否已经获取了优惠卷——&gt; 扣减库存。</p>
<blockquote>
<p>为什么不使用synchronized来保证原子性</p>
</blockquote>
<p>用<code>synchronized</code>代码块可以在Java代码层面上确保操作的原子性，但在分布式环境中可能存在性能问题。而使用Lua脚本可以在Redis服务器端执行原子操作，避免了并发访问的问题，并且可以减少网络开销。因此，根据具体的需求和场景，可以选择适合的方式来保证操作的原子性。</p>
<p>6.线程池异步生成订单</p>
<p>  再用户获取到优惠卷，要完成商品减少库存、判断用户身份、生成订单、邮箱提醒、到支付宝扣去余额等操作，这种涉及到金钱需要保证原子性，且用了大部分第三方服务的原子性错做，响应时间长，为了提高提高响应速度，所以这一操作使用线程池完成异步生成订单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E7%82%B9%E8%AF%84/" data-id="cltu174th001q48nudn0rdo17" data-title="点评.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/项目/聊天网站" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E8%81%8A%E5%A4%A9%E7%BD%91%E7%AB%99/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E8%81%8A%E5%A4%A9%E7%BD%91%E7%AB%99/">聊天网站.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="仿网页版QQ"><a href="#仿网页版QQ" class="headerlink" title="仿网页版QQ"></a>仿网页版QQ</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>基于websocket实现,前端发送可以转为History类型的json，后端通过一个存储用户id与用户session之间映射的map判断用户是否在线，如果用户不在线，讲history对象的state属性置为0，若在线置为1并通过ws发送给接收方。然后把history对象存储到redis的一个list集合，每3秒的所有history都会存到同一个list里面。服务端开启定时任务，定时任务会获取前三秒存储到redis的单聊history存储到数据库并删除该list。</p>
<h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><p>基于websocket实现,前端发送可以转为History类型的json，后端从数据库中查找history对象toId对应群里所有用户id，再通过一个存储用户id与用户session之间映射的map查找到群里在线的用户id。将其存储redis的map类型，key为表示是哪个时间段的消息，hkey为history，hval为查找到的用户id集合(StrUtil.join()方法转为一定格式的字符串)。然后对每个在线用户通过ws发送消息。服务端开启定时任务，定时任务会获取前三秒存储到redis的群聊history存储到数据库，并解析出那些些用户在每个群聊获取到的history的id最大值，并去修改数据库存储用户和群关系表的rec_id字段（存储用户最后接收到该群聊的消息的id），最后删除redis键值对。</p>
<p>【当用户量少的时候可以在history表中插入数据，因为historyId主键是自增的，根据数据库索引优化插入数据效率很高；当然这里让user_group_relation关系表的userId和groupId形成聚合索引，虽然增加了索引表，但是相对于只存到一个history的大量记录来说还是减少了存储】</p>
<h3 id="朋友圈"><a href="#朋友圈" class="headerlink" title="朋友圈"></a>朋友圈</h3><p>参考点评项目的博客功能。</p>
<h3 id="消息漫游"><a href="#消息漫游" class="headerlink" title="消息漫游"></a>消息漫游</h3><p>就是获取用户离线状态下未接收到的消息。对于单聊模块，通过历史记录的toId和state可以查询到，<code>细节上是通过history表自连接查询到根据fromId分组的最后的历史记录和count，返回给前端，如果用户像详细看哪个消息，通过前端点击后就查询所有fromId和userId之间的history，并存储到redis再通过定时任务将那些记录的state都改为1</code>。对于群聊模块，通过用户与群关系表的rec_id字段和对应群聊最后的history的id字段判断是否有漫游的消息，然后细节方面和单聊一样通过前端点击获取所有历史记录</p>
<h3 id="获取好友列表"><a href="#获取好友列表" class="headerlink" title="获取好友列表"></a>获取好友列表</h3><p>前端通过树形控件懒加载先获取所有的分组，然后再获取分组下的用户</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><blockquote>
<p>sys_user用户表</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT 				#唯一id</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">15</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>					#用户名唯一且不为空</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">NULL</span>                    #密码不为空</span><br><span class="line">`realname` <span class="type">varchar</span>(<span class="number">15</span>)  <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>           #真实姓名用于找回或忘记密码作为密保</span><br><span class="line">`college` <span class="type">varchar</span>(<span class="number">15</span>)  <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>            #学校用于找回或忘记密码作为密保</span><br><span class="line">`status` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>			 #用户状态<span class="number">1</span>为在线，<span class="number">0</span>为离线</span><br></pre></td></tr></table></figure>



<blockquote>
<p>tb_group分组表</p>
</blockquote>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;分组id&#x27;</span>,</span><br><span class="line">`group_name` <span class="type">varchar</span>(<span class="number">25</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分组名称&#x27;</span>,</span><br><span class="line">`max_num` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">200</span> COMMENT <span class="string">&#x27;分组最多可以有多少用户&#x27;</span>,</span><br><span class="line">`now_num` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分组当前用户数量&#x27;</span>,</span><br><span class="line">`own_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;该分组属于哪个用户&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tb_friend好友表</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`friend_note` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;好友备注&#x27;</span>,</span><br><span class="line">`group_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;处于哪个分组&#x27;</span>,</span><br><span class="line">`friend_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;好友id&#x27;</span>,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tb_history历史记录表</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`fromId` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;消息发送方的id&#x27;</span>,</span><br><span class="line">`toId` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;消息接收方的id(用户或群聊)&#x27;</span>,</span><br><span class="line">`content` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;消息内容&#x27;</span>,</span><br><span class="line">`state` tinyint(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;消息是否被接收到,0:未接受到,1:接收到,2:群聊消息&#x27;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tb_organization群组表</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `org_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;群名&#x27;</span>,</span><br><span class="line"> `max_num` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">200</span> COMMENT <span class="string">&#x27;群最多有多少人&#x27;</span>,</span><br><span class="line"> `now_num` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;群现在人数&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tb_user_org用户与群组关系表</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `org_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;群id&#x27;</span>,</span><br><span class="line">  `rec_id` <span class="type">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;当前用户读到该群最后一条历史记录的id&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h2 id="前缀树敏感词脱敏"><a href="#前缀树敏感词脱敏" class="headerlink" title="前缀树敏感词脱敏"></a>前缀树敏感词脱敏</h2><p>构建前缀树是放到静态代码块中，在项目根目录下放着一个记录好的敏感词文本文件，在静态代码块中通过这个文本文件来构造前缀树。</p>
<p>敏感词脱敏是使用三个指针，一个指向前缀树，其他两个是用于使用双指针法来查找敏感词的。具体过程为，指针1一直指向前缀树的根节点，指针2和指针3在没有找到疑似敏感词时时一起移动的。当指针2指向的文字在指针1的某个字点中,就为疑似找到敏感词，指针2就一直指向该处作为疑似敏感词的头指针，临时指针指向前缀树中被匹配的节点，指针3一直向后查找，直到确认该词为敏感词，就将指针2与指针3之间的文本全部替换为*号.</p>
<p><img src="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E8%81%8A%E5%A4%A9%E7%BD%91%E7%AB%99/20200423103755739.png" alt="在这里插入图片描述"></p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><ul>
<li><p>配置类</p>
<p>WebSocketConfigurer接口：registerWebSockethandlers()方法，将路径和处理器映射。</p>
</li>
<li><p>自动配置类</p>
<p>spring-boot-autoconfigure依赖下websocket目录有</p>
<p>WebSocketMessagingAutoConfiguration</p>
<p>WebSocketServletAutoConfiguration</p>
<p>WebSocketReactiveAutoConfiguration</p>
</li>
<li><p>核心类</p>
<p>WebSocketSession接口</p>
<p>WebSocketHandler接口</p>
<p>WebSocketMessage接口</p>
</li>
</ul>
<h1 id="使用websocket时的问题"><a href="#使用websocket时的问题" class="headerlink" title="使用websocket时的问题"></a>使用websocket时的问题</h1><p>主要有Bean注入和无法获取principal</p>
<blockquote>
<p>原生websocket，使用到原生注解如@OnOpen等注解的对象使用@Autowired注解自动装配Bean时，出现null异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChatService chatService;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>WebSocket 是多实例单线程的。每当有新的 WebSocket 连接建立时，都会创建一个新的 WebSocket 实例。这些新的 WebSocket 实例需要访问 Spring 容器中的 Bean。</p>
<p>问题就在于，如果在 WebSocket 实例中使用 <code>@Autowired</code> 注解来注入 Spring 容器中的 Bean，那么只有在整个应用程序启动时，Spring 容器才会创建一个 Bean 实例并将其注入到 WebSocket 实例中。而对于之后创建的新的 WebSocket 实例，Spring 容器不会再次创建和注入新的 Bean 实例。因此，这些新的 WebSocket 实例中的 <code>@Autowired</code> 注解的 Bean 将会是 null。</p>
<p><strong>解决办法：</strong></p>
<p>1.使用 <code>prototype</code> 作用域来声明需要注入到 WebSocket 中的 Bean。<code>prototype</code> 作用域的 Bean 在每次使用时都会创建一个新的实例。这样在新的 WebSocket 实例创建时，就会创建一个新的 Bean 实例并注入到 WebSocket 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.还是使用单例Bean，但是将该对象用static修饰，在Spring容器启动时就给该静态对象赋值。—-<strong>使用的是该方法解决的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChatService</span><span class="params">(ChatService chat)</span> &#123;</span><br><span class="line">        ChatController.chatService = chat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChatService chatService;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无法获取到principal</p>
</blockquote>
<p><strong>问题</strong></p>
<p>想在WebSoketSession连接建立时获取到principal，并建立用户与WebSocketSession映射。跟踪WebSocketSession建立，知道principal是在SecurityContext得到。但是不管是在登陆后将Authentication放入SecurityContext还是debug模式下在协议升级时将Authentication放入SecurityContext都无法在WebSocketSession中得到。</p>
<p><strong>原因</strong></p>
<p>WebSocket协议本质上是一种无状态的通信协议，与HTTP不同，它不维护会话（Session）状态。每个WebSocket连接都是独立的，不会自动与HTTP会话相关联。</p>
<p><strong>解决</strong></p>
<p>用户登录后，用户信息会返回给前端，在websocket连接url上携带着用户id，然后在websocket连接建立时建立映射。</p>
<p><strong>跟踪WebSocketSession给userPrincipal赋值</strong></p>
<ul>
<li><p>通过继承AbstractWebSocketHandler的handler的afterConnectionEstablished方法，知道afterConnectionEstablished方法的参数是</p>
<p>StandardWebSocketSession类的对象</p>
</li>
<li><p>通过StandardWebSocketSession类的initializeNativeSession方法,跟踪到userPrincipal是由WsSession的getUserPrincipal方法赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeNativeSession</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>.user = session.getUserPrincipal();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给WsSession的构造方法断点，并根据栈信息知道是由WsHttpUpgradeHandler的init方法来创建的WsSession对象，执行构造方法传递的参数是由属性handshakeRequest的getUserPrincipal方法赋值的，handshakeRequest是在preInit方法赋值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(WebConnection connection)</span> &#123;</span><br><span class="line">       ....</span><br><span class="line">           wsSession = <span class="keyword">new</span> <span class="title class_">WsSession</span>(wsRemoteEndpointServer,</span><br><span class="line">                   webSocketContainer, handshakeRequest.getRequestURI(),</span><br><span class="line">                   handshakeRequest.getParameterMap(),</span><br><span class="line">                   handshakeRequest.getQueryString(),</span><br><span class="line">                   handshakeRequest.getUserPrincipal(), httpSessionId,</span><br><span class="line">                   negotiatedExtensions, subProtocol, pathParameters, secure,</span><br><span class="line">                   serverEndpointConfig);</span><br><span class="line">           </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInit</span><span class="params">(ServerEndpointConfig serverEndpointConfig,</span></span><br><span class="line"><span class="params">           WsServerContainer wsc, WsHandshakeRequest handshakeRequest,</span></span><br><span class="line"><span class="params">           List&lt;Extension&gt; negotiatedExtensionsPhase2, String subProtocol,</span></span><br><span class="line"><span class="params">           Transformation transformation, Map&lt;String,String&gt; pathParameters,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> secure)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="built_in">this</span>.handshakeRequest = handshakeRequest;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>handshakeRequest</strong>的getUserPrincipal是由构造方法的HttpServletRequest的getUserPrincipal结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Principal <span class="title function_">getUserPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> userPrincipal;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WsHandshakeRequest</span><span class="params">(HttpServletRequest request, Map&lt;String,String&gt; pathParams)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">       userPrincipal = request.getUserPrincipal();</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>这里需要知道给priInit方法的handshakeRequest是哪个实现类，通过给preInit方法断点，并根据栈信息跟踪到UpgradeUtil的doUpgrade和WsServerContainer的doUpgrade方法可知传递的是具体实现类是SecurityContextHolderAwareRequestWrapper，而SecurityContextHolderAwareRequestWrapper的getUserPrincipal方法是从SpringSecurity中获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Authentication <span class="title function_">getAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="keyword">return</span> (!<span class="built_in">this</span>.trustResolver.isAnonymous(auth)) ? auth : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：userPrincipal是通过HandShakeRequest，WsSession，StandardWebSocketSession依次传递的，而HadShakeRequest实现类获取userPrincipal是通过SecurityContext获取到的。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E8%81%8A%E5%A4%A9%E7%BD%91%E7%AB%99/" data-id="cltu174th001r48nu18ynccbl" data-title="聊天网站.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/juc/">juc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/11/note/jvm/jvm/">jvm.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/AQS/">AQS.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/Future/">Future.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/ConcurrentHashMap/">ConcurrentHashMap.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/Executor/">Executor.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 1Stack1<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>