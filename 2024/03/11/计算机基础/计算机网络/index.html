<!DOCTYPE html>
<html lang="en">
	<head>
		
<title>计算机网络.md - 1Stack1</title>
<meta charset="utf-8" />
<meta name="keywords" content="" />
<meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=5"
/>
<meta name="generator" content="Hexo 7.1.1">
<link rel="stylesheet" href="/css/style.css?v=1710592518624">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap"
    media="all"
/>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/solarized-light.css"
/>
<script src="/js/core.js?v=1710592518624"></script>






<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js" async></script>
<!--<script src="" async></script>--> 
	</head>

	<body>
        <div class="header  ">
    <div class="container">
        <a class="logo" href="/" title="1Stack1">1Stack1</a>
        <ul class="nav">
            
                <li class="nav-item"><a href="/archives">Archives</a></li>
            
                <li class="nav-item"><a href="/about.html">About</a></li>
            
        </ul>
    </div>
</div>
        <div class="content">
	<div class="banner">
		<div class="container">
			<h1>计算机网络.md</h1>
			<div class="info"><span class="date">2024年3月11日</span>•1Stack1 
			
					《<a class="nexmoefont icon-appstore-fill -link" href="/categories/note/">note</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>》
				
				
					<a href="https://github.com/nexmoe/books/tree/master/source/_posts/计算机基础/计算机网络.md" target="_blank" rel="external nofollow noreferrer noopener">编辑</a>
				
			</div>
			
		</div>
	</div>
	<div class="container">
		<article class="post">
			<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote>
<p>什么是HTTP</p>
</blockquote>
<p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h2 id="HTTP头格式"><a href="#HTTP头格式" class="headerlink" title="HTTP头格式"></a>HTTP头格式</h2><p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524195350073.png" alt="image-20230524195350073"></p>
<h2 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h2><p>“1”字头（信息状态）：接收的请求正在处理</p>
<p>“2”字头（表示成功）：200（OK请求成功）、201（Created已创建）、204（No content无内容）、206（ Partial Content只需要其中一部分）</p>
<p>“3”字头（重定向）：301（Move Permanently永久移动 ）、302（Found临时移动）、304（Not Modified未修改——意思是指缓存未过期，不用重新下载，直接使用缓存。同时也能推断出服务器资源未被修改）</p>
<p>“4”字头（客户端错误）：400（Bad Request错误请求&#x2F;语法错误）、401（Unauthorized未认证&#x2F;未验证）、403（Forbidden禁止访问）、404（Not Found未找到——资源已消失&#x2F;网址打错了）、409（Conflict冲突——可能是新旧版本冲突）</p>
<p>“5”字头：（服务器错误）：500（Internet Server Error内部错误）、502（Bad Gateway网关&#x2F;代理错误）、503（Sever Unavailable超载或维护）</p>
<h2 id="Get和Post"><a href="#Get和Post" class="headerlink" title="Get和Post"></a>Get和Post</h2><p><strong>GET 的语义是从服务器获取指定的资源</strong>，GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 。</p>
<p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据。</p>
<blockquote>
<p>请说一下安全和幂等的概念</p>
</blockquote>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<blockquote>
<p>GET 请求可以带 body 吗？</p>
</blockquote>
<p>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><ul>
<li><p><strong>强制缓存</strong>，指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
</li>
<li><p><strong>协商缓存</strong>，协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98etag.png" alt="img"></p>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><blockquote>
<p>HTTP与HTTPS的区别</p>
</blockquote>
<ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<blockquote>
<p>HTTPS解决了那些问题</p>
</blockquote>
<p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容。——–通信使用明文（不加密）</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染。———-无法证明报文的完整性</li>
<li><strong>冒充风险</strong>，比如冒充网站。———不验证通信方的身份</li>
</ul>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，。</li>
<li><strong>身份证书</strong>：证明网站是官网。</li>
</ul>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p>
<blockquote>
<p>HTTPS 是如何解决上面的三个风险的？</p>
</blockquote>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<blockquote>
<p>描述一下混合加密</p>
</blockquote>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="混合加密"></p>
<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<blockquote>
<p>采用「混合加密」的方式的原因：</p>
</blockquote>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<blockquote>
<p>描述一下摘要算法 + 数字签名</p>
</blockquote>
<p>计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png" alt="img"></p>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，有两种流程：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt="img"></p>
<blockquote>
<p>TLS之RSA密钥交换算法握手过程</p>
</blockquote>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tls%E6%8F%A1%E6%89%8B.png" alt="img"></p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/https_rsa.png" alt="img"></p>
<blockquote>
<p>RSA的缺陷</p>
</blockquote>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><blockquote>
<p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上有什么改进</p>
</blockquote>
<ul>
<li><p>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接"></p>
</li>
<li><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为<strong>「队头堵塞」</strong>。（默认不开启）</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="管道网络传输"></p>
</li>
</ul>
<blockquote>
<p> HTTP&#x2F;1.1 还是有性能瓶颈</p>
</blockquote>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，造成队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<blockquote>
<p> HTTP&#x2F;1.1 该如何优化吗？</p>
</blockquote>
<ul>
<li>使用HTTP缓存来尽量避免发送 HTTP 请求</li>
<li>在需要发送 HTTP 请求时，减少请求次数<ul>
<li>减少重定向请求次数</li>
<li>合并请求</li>
<li>延迟发送请求（例如：树形控件的懒加载）</li>
</ul>
</li>
<li>减少服务器的 HTTP 响应的数据大小<ul>
<li>对响应的资源进行<strong>压缩</strong>，包括<strong>有损压缩</strong>和<strong>无损压缩</strong></li>
</ul>
</li>
</ul>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><blockquote>
<p>HTTP&#x2F;2相对于HTTP&#x2F;1.1有什么优化?</p>
</blockquote>
<p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25-HTTP2.png" alt="HTT/1 ~ HTTP/2"></p>
<p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ul>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ul>
<blockquote>
<p>说一下头部压缩</p>
</blockquote>
<p>对于常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，大大提高了编码效率，同时节约了带宽资源。</p>
<p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP&#x2F;2 连接时长或者请求次数。</p>
<blockquote>
<p>解释一下并发传输</p>
</blockquote>
<p>通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240316195337919.png" alt="image-20240316195337919"></p>
<p>客户端和服务器<strong>双方都可以建立 Stream</strong>，因为服务端可以主动推送资源给客户端， 客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<blockquote>
<p>介绍一下服务器主动推送资源</p>
</blockquote>
<p>比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分；在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数，如上图右边部分：</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240316195508650.png" alt="image-20240316195508650"></p>
<p>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240316195119573.png" alt="image-20240316195119573"></p>
<p>如上图，在 Stream 1 中通知客户端 CSS 资源即将到来，然后在 Stream 2 中发送 CSS 资源，注意 Stream 1 和 2 是可以<strong>并发</strong>的。</p>
<blockquote>
<p>HTTP&#x2F;2的缺点</p>
</blockquote>
<ul>
<li>队头阻塞；</li>
<li>TCP 与 TLS 的握手时延迟；</li>
<li>网络迁移需要重新连接；</li>
</ul>
<blockquote>
<p>为什么会队头阻塞</p>
</blockquote>
<p>HTTP&#x2F;2是基于TCP协议， TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524193952443.png" alt="image-20230524193952443"></p>
<blockquote>
<p>什么是网络迁移需要重新连接</p>
</blockquote>
<p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。</p>
<h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524194011145.png" alt="image-20230524194011145"></p>
<blockquote>
<p>QUIC的优点</p>
</blockquote>
<ul>
<li>无队头阻塞；</li>
<li>更快的连接建立；</li>
<li>连接迁移；</li>
</ul>
<blockquote>
<p>QUIC为什么没有对头阻塞</p>
</blockquote>
<p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，但是 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。虽然QUIC 对每个数据包都有一个序号唯一标识，协议会保证数据包的可靠性。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP&#x2F;3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP&#x2F;3。</p>
<p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524194223794.png" alt="image-20230524194223794"></p>
<blockquote>
<p>如何保证连接迁移</p>
</blockquote>
<p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WiFi 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，</p>
<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<blockquote>
<p>HTTP&#x2F;3如何解决动态表问题</p>
</blockquote>
<p><strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。</p>
<p>QUIC 会有两个特殊的单向流：</p>
<ul>
<li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方；</li>
<li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li>
</ul>
<p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><blockquote>
<p>TCP的作用</p>
</blockquote>
<p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<blockquote>
<p>如何唯一的确定一个TCP连接</p>
</blockquote>
<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524200036746.png" alt="image-20230524200036746"></p>
<p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p>
</blockquote>
<p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230436594.png" alt="img"></p>
<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li><p>文件描述符限制</p>
</li>
<li><p>内存限制</p>
</li>
</ul>
<blockquote>
<p>TCP 如何保证传输的可靠性？</p>
</blockquote>
<ol>
<li><strong>根据序列号来实现数据包重新排序以及去重</strong></li>
<li><strong>超时重传</strong> </li>
<li><strong>流量控制</strong> </li>
<li><strong>拥塞控制</strong></li>
</ol>
<h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524195426514.png" alt="image-20230524195426514"></p>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><blockquote>
<p>阐述一下TCP三次握手过程</p>
</blockquote>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
</ul>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230500953.png" alt="第一个报文 —— SYN 报文"></p>
<ul>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
</ul>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230504118.png" alt="第二个报文 —— SYN + ACK 报文"></p>
<ul>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
</ul>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230508297.png" alt="第三个报文 —— ACK 报文"></p>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>。</p>
<blockquote>
<p>为什么使用三次握手</p>
</blockquote>
<p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<blockquote>
<p>为什么两次握手无法防止历史连接建立</p>
</blockquote>
<p><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<blockquote>
<p>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</p>
</blockquote>
<p>主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ul>
<blockquote>
<p>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</p>
</blockquote>
<p><strong>当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」，是非常没有效率的。</p>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<blockquote>
<p>为什么挥手需要四次？</p>
</blockquote>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<blockquote>
<p>为什么 TIME_WAIT 等待的时间是 2MSL？</p>
</blockquote>
<p><code>MSL</code> 是 <strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：如果第四次挥手丢失(也就是主动断开方ACK丢包)，被动断开方重新发送FIN，ACK传输时间+重发FIN传输时间 &lt;&#x3D;2MSL</p>
<blockquote>
<p>为什么需要 TIME_WAIT 状态？</p>
</blockquote>
<ul>
<li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p>
<p>TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
</li>
<li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p>
<p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
</li>
</ul>
<blockquote>
<p>过多的 TIME-WAIT 状态有什么危害</p>
</blockquote>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><blockquote>
<p>TCP重传机制包括哪些？</p>
</blockquote>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK方法</li>
<li>D-SACK</li>
</ul>
<blockquote>
<p>什么是超时重传</p>
</blockquote>
<p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据.</p>
<blockquote>
<p>TCP 会发生超时重传的情况</p>
</blockquote>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p><code>RTT</code> 指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。</p>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</strong></p>
<p><strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>什么是快速重传</p>
</blockquote>
<p><strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<blockquote>
<p>快速重传的问题</p>
</blockquote>
<p><strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p>
<p>假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p>
<blockquote>
<p>什么是SACK方法</p>
</blockquote>
<p>在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.jpg" alt="选择性确认"></p>
<h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p>
<p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25.jpg" alt="窗口探测"></p>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><blockquote>
<p>什么是TCP流量控制</p>
</blockquote>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></p>
<blockquote>
<p>为什么需要流量控制</p>
</blockquote>
<p>双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在发数据的话，接收方只能把收到的数据包丢掉。不仅出现丢包问题还浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><blockquote>
<p>TCP有流量控制了为什么要有拥塞控制？</p>
</blockquote>
<p>计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p><strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<blockquote>
<p>如何知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<blockquote>
<p>什么是慢启动？</p>
</blockquote>
<p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，</p>
<blockquote>
<p>慢启动过程</p>
</blockquote>
<p>慢启动的算法规则：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p>慢启动算法的变化过程如下图：</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/27.jpg" alt="慢启动算法"></p>
<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<blockquote>
<p> 什么是拥塞避免算法</p>
</blockquote>
<p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p>
<p>规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p>
<p>假定 <code>ssthresh</code> 为 <code>8</code>：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
<p>拥塞避免算法的变化过程如下图：</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/28.jpg" alt="拥塞避免"></p>
<p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<blockquote>
<p>什么是拥塞发生算法</p>
</blockquote>
<p>在拥塞避免算法中就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<blockquote>
<p>发生超时重传的拥塞发生算法</p>
</blockquote>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/29.jpg" alt="拥塞发送 —— 超时重传"></p>
<blockquote>
<p>发生快速重传的拥塞发生算法</p>
</blockquote>
<p> <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<blockquote>
<p>快速恢复算法</p>
</blockquote>
<p>快速重传和快速恢复算法一般同时使用，</p>
<p>进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p>快速恢复算法的变化过程如下图：</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png" alt="快速重传和快速恢复"></p>
<h2 id="TCP-快速建立连接"><a href="#TCP-快速建立连接" class="headerlink" title="TCP 快速建立连接"></a>TCP 快速建立连接</h2><p>由于第三次握手是可以携带数据的，但是在下一次（不是同个 TCP 连接的下一次）发起 HTTP GET 请求时，经历的 RTT 也是一样</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/44.jpg" alt="常规 HTTP 请求"></p>
<p>在 Linux 3.7 内核版本中，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-Wireshark/45.jpg" alt="常规 HTTP 请求 与 Fast  Open HTTP 请求"></p>
<h2 id="优化TCP"><a href="#优化TCP" class="headerlink" title="优化TCP"></a>优化TCP</h2><h3 id="三次握手优化"><a href="#三次握手优化" class="headerlink" title="三次握手优化"></a>三次握手优化</h3><blockquote>
<p>客户端的优化</p>
</blockquote>
<p>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传的次数。</p>
<blockquote>
<p>服务端的优化</p>
</blockquote>
<p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以调整 SYN 半连接队列的大小。</p>
<p>如果遭受 SYN 攻击，在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</p>
<p>在全连接队列满了还可以用 RST 通知客户端连接建立失败。</p>
<p>如果 accpet 队列溢出严重，可以提高队列大小。</p>
<blockquote>
<p>什么是syncookies ？</p>
</blockquote>
<p>syncookies 的工作原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.jpg" alt="开启 syncookies 功能"></p>
<blockquote>
<p>绕过三次握手</p>
</blockquote>
<p>TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，同时必须保证服务端和客户端同时支持。</p>
<h3 id="四次挥手优化"><a href="#四次挥手优化" class="headerlink" title="四次挥手优化"></a>四次挥手优化</h3><blockquote>
<p>主动方的优化</p>
</blockquote>
<p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文。</p>
<p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，可以设置最大数量，超过时连接也会直接释放。</p>
<p>当 TIME_WAIT 状态过多时，可以将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p>
<blockquote>
<p>被动方的优化</p>
</blockquote>
<p>在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p>
<p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，就会重发 FIN 报文。</p>
<h3 id="数据传输优化"><a href="#数据传输优化" class="headerlink" title="数据传输优化"></a>数据传输优化</h3><p>TCP 可靠性是通过 ACK 确认报文实现的，又依赖滑动窗口提升了发送速度也兼顾了接收方的处理能力。</p>
<p>可以提升滑动窗口的上限来提升发送速度必须。</p>
<h2 id="面向字节流协议"><a href="#面向字节流协议" class="headerlink" title="面向字节流协议"></a>面向字节流协议</h2><blockquote>
<p>为什么 UDP 是面向报文的协议？</p>
</blockquote>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，再组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<blockquote>
<p>为什么 TCP 是面向字节流的协议？</p>
</blockquote>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p>
<blockquote>
<p>为什么TCP会有粘包现象</p>
</blockquote>
<p>当发送方发送多个小数据包时，由于TCP协议的流量控制和拥塞控制机制，可能会将这些不满足MSS的数据包合并为一个大的TCP分段进行传输，或者将超过MSS的数据包强行拆分。—–&gt;Nagle算法</p>
<p>接收方由于用户进程不及时接收数据，从而导致粘包现象。下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p>
<blockquote>
<p>如何解决粘包？</p>
</blockquote>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<ul>
<li>固定长度的消息；——-&gt; 不常使用</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。—–&gt;比如：自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大，当接收方接收到包头的大小后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</li>
</ul>
<h2 id="TCP序列号"><a href="#TCP序列号" class="headerlink" title="TCP序列号"></a>TCP序列号</h2><blockquote>
<p>为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？</p>
</blockquote>
<p>主要原因是为了防止历史报文被下一个相同四元组的连接接收。</p>
<blockquote>
<p>序列号最大为4G，如果发生回绕怎么办？</p>
</blockquote>
<p>TCP 头部会使用时间戳选项，要求连接双方维护最近一次收到的数据包的时间戳，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<blockquote>
<p>序列号是如何变化的？</p>
</blockquote>
<ul>
<li><strong>序列号（用来解决乱序问题） &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>确认号（用来解决丢包问题） &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<blockquote>
<p>什么是确认号？</p>
</blockquote>
<p>指下一次「期望」收到的数据的序列号发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<p>UDP头格式</p>
</blockquote>
<p><img src="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230524201251619.png" alt="image-20230524201251619"></p>
<blockquote>
<p>为什么UDP有报文长度字段</p>
</blockquote>
<p>虽然IP层记录了消息长度，但IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，这时就需要报文长度字段来确定消息长度。</p>
<h2 id="TCP与UDP对比"><a href="#TCP与UDP对比" class="headerlink" title="TCP与UDP对比"></a>TCP与UDP对比</h2><blockquote>
<p>TCP 和 UDP 区别：</p>
</blockquote>
<p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<blockquote>
<p>TCP 和 UDP 应用场景</p>
</blockquote>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p> 由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<blockquote>
<p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p>
</blockquote>
<p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<h2 id="端口使用"><a href="#端口使用" class="headerlink" title="端口使用"></a>端口使用</h2><blockquote>
<p>TCP 和 UDP 可以同时绑定相同的端口吗？</p>
</blockquote>
<p>可以的。</p>
<p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，互不影响。</p>
<blockquote>
<p>多个 TCP 服务进程可以同时绑定同一个端口吗？</p>
</blockquote>
<p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。</p>
<blockquote>
<p>客户端的端口可以重复使用吗？</p>
</blockquote>
<p>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。</p>
<p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。</p>

			<br>
			
		</article>
	</div>
	<div class="other">
		<div class="container">
			<nav class="post-nav">

    
         <!-- 先找到与当前文字相同的目录 -->
            
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                 <!-- 在找到当前文章所在的 index -->
                    
                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                         <!-- 下一篇文章 --> 
                            <div class="new">
                                <span>下一章</span>
                                <a href="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"> 操作系统.md</a>
                            </div>
                        

                    
                         

                        

                        

                    
                         

                          <!-- 上一篇文章 --> 
                            <div class="old">
                                <span>上一章</span>
                                <a href="/2024/03/11/%E9%A1%B9%E7%9B%AE/lottery/"> lottery.md</a>
                            </div>
                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                         

                        

                        

                    
                
            
                 
                
            
                 
                
            
                 
                
            
                 
                
            
        
    
        
    

    
        
    
        
    

    
        
    
        
    

    
        
    
        
    

    
        
    
        
    

    
        
    
         <!-- 先找到与当前文字相同的目录 -->
            
            
                 
                
            
                 
                 <!-- 在找到当前文章所在的 index -->
                    
                    
                         

                        

                         <!-- 下一篇文章 --> 
                            <div class="new">
                                <span>下一章</span>
                                <a href="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"> 操作系统.md</a>
                            </div>
                        

                    
                         

                        

                        

                    
                
            
        
    

    
        
    
        
    

</nav> 
		</div>
	</div>
	<div class="container comment">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
	</div>
</div>
		<div class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-left">1Stack1</div>
            <div class="footer-right"> 
                <div class="footer-links">
                    
                        <a target="_blank" rel="noopener" href="https://nexmoe.com/">折影轻梦</a>
                    
                        <a target="_blank" rel="noopener" href="https://github.com/Yet-The-Books/hexo-theme-yet-the-books">还有书籍</a>
                    
                </div>
                <div calss="footer-copyright">&copy; 2024 1Stack1
                    Using <a rel="noreferrer" href="http://hexo.io/" target="_blank">Hexo</a> 
                    &amp; <a rel="noreferrer" href="https://github.com/Yet-The-Books/hexo-theme-yet-the-books" target="_blank">Yet The Books</a>
                </div>
            </div>  
        </div>
    </div>
</div>
	</body>
</html>
