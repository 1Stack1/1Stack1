<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>mit6.824.md | 1Stack1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="基于Raft协议实现的KV数据库，实现了数据的查询、存储和分布式的容错。在集群中的每个服务器由Raft节点和状态机组成，其中Raft节点是用来支持Raft协议来实现数据一致性，状态机用来存储数据。 基本Java项目 idea解析不了java文件  右键指定目录，在Mark Direction as 中将目录作为需要的目录。 删除.idea文件 在file-&gt;inviadate and res">
<meta property="og:type" content="article">
<meta property="og:title" content="mit6.824.md">
<meta property="og:url" content="https://username.github.io/2024/03/11/note/%E9%A1%B9%E7%9B%AE/mit824/index.html">
<meta property="og:site_name" content="1Stack1">
<meta property="og:description" content="基于Raft协议实现的KV数据库，实现了数据的查询、存储和分布式的容错。在集群中的每个服务器由Raft节点和状态机组成，其中Raft节点是用来支持Raft协议来实现数据一致性，状态机用来存储数据。 基本Java项目 idea解析不了java文件  右键指定目录，在Mark Direction as 中将目录作为需要的目录。 删除.idea文件 在file-&gt;inviadate and res">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-11T15:50:50.000Z">
<meta property="article:modified_time" content="2024-03-13T16:33:50.820Z">
<meta property="article:author" content="1Stack1">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="1Stack1" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">1Stack1</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://username.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-note/项目/mit824" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/mit824/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T15:50:50.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      mit6.824.md
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>基于Raft协议实现的KV数据库，实现了数据的查询、存储和分布式的容错。在集群中的每个服务器由Raft节点和状态机组成，其中Raft节点是用来支持Raft协议来实现数据一致性，状态机用来存储数据。</p>
<h1 id="基本Java项目"><a href="#基本Java项目" class="headerlink" title="基本Java项目"></a>基本Java项目</h1><blockquote>
<p>idea解析不了java文件</p>
</blockquote>
<p>右键指定目录，在Mark Direction as 中将目录作为需要的目录。</p>
<p>删除.idea文件</p>
<p>在file-&gt;inviadate and restart处重启idea。</p>
<blockquote>
<p>如何引入依赖</p>
</blockquote>
<p>创建一个lib目录，将所需依赖的jar包放入lib目录。</p>
<p>在project struction中的library中将该目录下的jar包add进去</p>
<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>Raft结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        		 sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers     		 []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister 		 *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        		 <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead      		 <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line">	<span class="comment">//超时选举</span></span><br><span class="line">	currentTerm 	 <span class="type">int</span> <span class="comment">//最后一次收到的服务的任期</span></span><br><span class="line">	votedFor 		 <span class="type">int</span> <span class="comment">//在当前term下收到选举的candidateId</span></span><br><span class="line">	voteCount 		 <span class="type">int</span><span class="comment">//当前term收到的投票成功数</span></span><br><span class="line">	status 			 Status <span class="comment">//节点类型</span></span><br><span class="line">	overtime 		 time.Duration <span class="comment">//任期倒计时总长</span></span><br><span class="line">	timer    		 *time.Ticker <span class="comment">//实现倒计时功能</span></span><br><span class="line">	<span class="comment">//日志复制</span></span><br><span class="line">	logs 			 []LogEntry</span><br><span class="line">	commitIndex 	 <span class="type">int</span> <span class="comment">//通过对 matchIndex 排序找中位数的 index ，就是大多数节点都拥有的日志范围，将其设置为 commitIndex 。</span></span><br><span class="line">	lastApplied 	 <span class="type">int</span></span><br><span class="line">	nextIndex 		 []<span class="type">int</span> <span class="comment">//每个服务器占一个slot，是下一个心跳发送给Follower的index；是Leader对Follower同步的猜测</span></span><br><span class="line">	matchIndex 		 []<span class="type">int</span> <span class="comment">//记录Leader和对应Follower匹配的长度，元素的记录将要复制给机器的日志的索引;实际获知到的同步进度</span></span><br><span class="line">	applyChan 		 <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	<span class="comment">//日志快照</span></span><br><span class="line">	lastIncludeIndex <span class="type">int</span></span><br><span class="line">	lastIncludeTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab2A选举"><a href="#lab2A选举" class="headerlink" title="lab2A选举"></a>lab2A选举</h2><h3 id="超时选举概述"><a href="#超时选举概述" class="headerlink" title="超时选举概述"></a>超时选举概述</h3><p>raft为了满足其一致性，需要选出一个Leader。超时选举过程是每个节点都有一个自己的超时时间，如果在这段时间内没有收到心跳，就会触发超时选举，将自己变为Candidate，给其他节点发送投票请求，如果满足投票条件，其他节点会给自己投票，当自己票数过半且没有因为term过小或日志不满足要求等条件，该节点会变为Leader。为了防止多个节点同时发起投票产生平票等问题，Raft会给每个节点分配一个随机的选举超时时间（Election Timeout）。</p>
<h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>Node超过定时时间没有收到心跳，自己变为Candidate，发送选举请求，通过RPC调用其他Node的处理选举模块，下面是选举请求参数.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时选举</span></span><br><span class="line">Term 			<span class="type">int</span> <span class="comment">//candidate任期</span></span><br><span class="line">CandidateId 	<span class="type">int</span> <span class="comment">//candidate&#x27;s index in peers</span></span><br><span class="line"><span class="comment">//日志复制</span></span><br><span class="line">LastLogIndex 	<span class="type">int</span> <span class="comment">//最后一个日志的index</span></span><br><span class="line">LastLogTerm 	<span class="type">int</span>  <span class="comment">//最后一个日志的term</span></span><br></pre></td></tr></table></figure>

<p>被RPC调用的节点开始处理选举请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Candidate的term比自己小，或者自己已经投过票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt;= rf.currentTerm &#123;</span><br><span class="line">    拒绝投票并返回自己的任期以供Candidate更新</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修改自己的raft节点参数</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.如果Candidate的日志最后的term比自己的小</span></span><br><span class="line"><span class="comment">//2.最后日志的term相等，但是Candidate最后日志的index比自己的小</span></span><br><span class="line"><span class="comment">//拒绝投票</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(args.LastLogTerm &lt; rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term || (args.LastLogTerm ==  rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &lt; <span class="built_in">len</span>(rf.logs) + rf.lastIncludeIndex))&#123;</span><br><span class="line">    拒绝投票</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">投票并更新自己的超时时间，voteFor等参数</span><br></pre></td></tr></table></figure>

<p>Candidate来处理RPC调用结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Term 			<span class="type">int</span> <span class="comment">//给candidate发送自己的currentTerm，以便candidate更新自己的currentTerm</span></span><br><span class="line">VoteGranted 	<span class="type">bool</span> <span class="comment">//是否给candidate投票</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到之前请求的响应</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">    直接忽略</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理返回结果</span></span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123; <span class="comment">//给自己投票</span></span><br><span class="line">    <span class="keyword">if</span> rf.voteCount &lt;= <span class="built_in">len</span>(rf.peers) / <span class="number">2</span>&#123;</span><br><span class="line">        rf.voteCount++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rf.voteCount &gt; <span class="built_in">len</span>(rf.peers) / <span class="number">2</span>&#123;</span><br><span class="line">        <span class="number">1.</span>将投票数量变为<span class="number">0</span>，以保证投票的幂等性</span><br><span class="line">        <span class="number">2.</span>将自己的超时时间更新为心跳间隔，此后每隔一段时间发送一次心跳</span><br><span class="line">        <span class="number">3.</span>更新自己的状态为Leader     </span><br><span class="line">        <span class="number">4.</span>更新nextIndex和matchIndex，这是日志复制的核心</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;	<span class="comment">//拒绝给自己投票</span></span><br><span class="line">    更新任期，投票数量，voteFor等raft属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="心跳概述"><a href="#心跳概述" class="headerlink" title="心跳概述"></a>心跳概述</h3><p>Leader每个一段时间都会给其他节点发送一次心跳，使其他节点更新自己的超时时间，以保证其他节点不会竞争成为其他Leader。超时选举也算是心跳请求，也是使其他节点不能成为Leader，但是比较特殊的是自己要成为Leader。除此之外心跳还承担日志复制的责任，来使Follower和Leader的日志相同。</p>
<p>注意的是raft要满足心跳间隔&lt;选举定时，以保证Follower在选举定时到期之前收到心跳消息，避免不必要的选举；且满足RPC时间间隔 &lt; 心跳间隔，这样可以在下一个心跳间隔之前完成RPC请求处理。</p>
<h3 id="心跳过程"><a href="#心跳过程" class="headerlink" title="心跳过程"></a>心跳过程</h3><p>Leader每隔一段时间通过RPC给Follower发送一个心跳参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时选举</span></span><br><span class="line">LeaderId 		<span class="type">int</span></span><br><span class="line">Term 			<span class="type">int</span></span><br><span class="line"><span class="comment">//日志复制</span></span><br><span class="line">PreLogIndex 	<span class="type">int</span> <span class="comment">//前置日志索引，用来确定Follower从什么位置开始复制日志</span></span><br><span class="line">PreLogTerm 		<span class="type">int</span> <span class="comment">//前置日志任期，PreLogIndex处日志的任期，raft日志的特性可以根据term比较来知道日志是否相同</span></span><br><span class="line">Entries 		[]LogEntry <span class="comment">//Leader从PreLogIndex-1开始的日志</span></span><br><span class="line">LeaderCommit 	<span class="type">int</span> <span class="comment">//Leader的CommitIndex,来使Follower知道自己的日志该提交到哪</span></span><br></pre></td></tr></table></figure>

<p>Follower处理心跳请求（为了叙述简单，以下没有考虑Lab2D日志快照）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己的term比Leader的还大</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">    返回自己的term以更新Leader的term</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">更新term、选举定时等raft属性</span><br><span class="line"></span><br><span class="line"><span class="comment">//PreLogIndex比自己快照下标还考前</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex &lt; rf.lastIncludeIndex&#123;</span><br><span class="line">    让Leader更新自己对应的nextIndex为自己的快照下标   </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志冲突</span></span><br><span class="line"><span class="comment">//1. 假如没有快照时自己logs在preLogIndex处没有日志</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex &gt; rf.lastIncludeIndex &amp;&amp; args.PreLogIndex &gt; rf.lastIncludeIndex + <span class="built_in">len</span>(rf.logs)&#123;</span><br><span class="line">    让Leader更新自己对应的nextIndex为自己的日志长度</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.自己与Leader在preLogIndex处的日志不相同</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex &gt; rf.lastIncludeIndex &amp;&amp; rf.logs[args.PreLogIndex - rf.lastIncludeIndex - <span class="number">1</span>].Term != args.PreLogTerm&#123;</span><br><span class="line">   	让Leader使用二分法更新自己对应的nextIndex</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果携带着日志</span></span><br><span class="line"><span class="keyword">if</span> args.Entries != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(args.Entries) &gt; <span class="number">0</span>&#123;</span><br><span class="line">    从PreLogIndex处复制日志</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从自己的日志提交下标到Leader的日志提交下标，开始遍历</span><br><span class="line"><span class="number">1.</span>先使自己的日志提交下标+<span class="number">1</span></span><br><span class="line"><span class="number">2.</span>响应日志给状态机</span><br><span class="line"><span class="number">3.</span>更新自己日志响应下标为日志提交下标</span><br></pre></td></tr></table></figure>

<p>Leader处理RPC结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Success 		<span class="type">bool</span></span><br><span class="line">Term 			<span class="type">int</span></span><br><span class="line">NextIndex 		<span class="type">int</span> <span class="comment">//Leader的nextIndex对应slot的值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是之前RPC响应结果</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term || rf.status != Leader || rf.nextIndex[followerId] != args.PreLogIndex&#123;</span><br><span class="line">    直接忽略</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;<span class="comment">//返回失败</span></span><br><span class="line">    <span class="comment">//如果是日志复制失败</span></span><br><span class="line">    <span class="keyword">if</span>  rf.currentTerm == reply.Term&#123;</span><br><span class="line">        更新Follower对应nextIndex为，Follower响应的结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出现网络分区</span></span><br><span class="line">    更新term、变为Follower、将心跳间隔变为选举定时   </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//返回成功</span></span><br><span class="line">    更新nextIndex和matchIndex    </span><br><span class="line">    得到matchIndex的中位数，该中位数就是哪个最新的日志被大部分节点锁拥有，也就作为Leader的新的comitIndex</span><br><span class="line">    从自己的日志提交下标到新的的日志提交下标，开始遍历</span><br><span class="line">    <span class="number">1.</span>先使自己的日志提交下标+<span class="number">1</span></span><br><span class="line">    <span class="number">2.</span>响应日志给状态机</span><br><span class="line">    <span class="number">3.</span>更新自己日志响应下标为日志提交下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="加锁问题"><a href="#加锁问题" class="headerlink" title="加锁问题"></a>加锁问题</h3><blockquote>
<p>为什么需要加锁</p>
</blockquote>
<p>像处理选举，日志复制等操作都需要修改和使用到raft的属性。如果不加锁可能会发生线程不安全问题。</p>
<blockquote>
<p>加锁时出现的问题</p>
</blockquote>
<p>ticker函数类似于每个raft的主函数，在一个while true循环里等待心跳超时或选举超时，然后发送选举或心跳RPC，而RPC参数是要copy节点的属性，需要加锁。</p>
<p>本来是在想在while true循环里加锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.timer.C:</span><br><span class="line">        <span class="keyword">switch</span> rf.status&#123;</span><br><span class="line">            <span class="keyword">case</span> Follower:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Candidate:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Leader:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在每一次循环刚开始就加锁会发生下面情况：</p>
<p>每个节点都是刚创建好就进入ticker函数，一进循环就加锁，此时所有每个节点都拿着自己的锁。</p>
<p>当有一个节点变为Candidate发送请求选举的RPC，然后等待其他节点处理该请求，但是处理请求RPC也需要加锁，此时该节点就要等到自己发送了选举请求释放锁才能处理该请求。这会导致所有节点都堆积到自己变为Candidate后释放锁后处理别的节点的请求，又因为自己是Candidate不会给同term的其他Candidate投票，就不会出现任何一个过半票的节点。然后他们都又重新在一个新的term来进行选举，又因为以上原因循环往复导致无法选出Leader。</p>
<p>所以就需要修改加锁时机，不能一上来就加锁，这里改为了等到选举时间或心跳间隔时间一到，再加锁，然后发送请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.timer.C:</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">switch</span> rf.status&#123;</span><br><span class="line">            <span class="keyword">case</span> Follower:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Candidate:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> Leader:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h3><blockquote>
<p>忽略之前RPC的返回值</p>
</blockquote>
<p>因为可能由于网络问题导致节点可能收到之前发送RPC的处理返回值，这时就需要将该返回值抛弃.</p>
<p>如：</p>
<p>1给2发送vote请求，2没来得及处理。但是1超过半票变为Leader，之后给2发送心跳，这时他俩的term就一样了。<br>此时2才来处理1的vote请求，给1的vote请求响应false。但是1还应该是Leader所以需要忽略该返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">   <span class="comment">//fmt.Println(&quot;收到之前vote的响应&quot;)</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否变为Leader</p>
</blockquote>
<p>Candidate需要判断自己票数是否过半来决定自己是否变为Leader，判断的时候不应该等到所有节点返回结果后统计决定是否变为Leader，而是一过半就变为Leader，因为那样会发生某个节点crash掉导致一直无法选出Leader。</p>
<h2 id="lab2B-日志复制"><a href="#lab2B-日志复制" class="headerlink" title="lab2B 日志复制"></a>lab2B 日志复制</h2><h3 id="日志复制概述"><a href="#日志复制概述" class="headerlink" title="日志复制概述"></a>日志复制概述</h3><p>一旦一个候选者成为 leader，它将开始处理客户端的请求。客户端的每个请求包含了一条需要执行到状态机的命令。leader 将命令追加到自己的日志记录，同时并发 AppendEntries RPCs 请求来进行日志复制。当日志安全的复制之后，leader 将日志应用到自己的状态机并将结果返回给客户端。</p>
<p>每条日志记录包含了leader 的任期和状态机命令。任期是为了检测日志之间的不一致：</p>
<p>• 如果两个日志的两条日志记录有相同的索引和任期，那么这两条日志记录中的命令必然也是相同的。<br>• 如果两个日志的两条日志记录有相同的索引和任期，那么这两个日志中的前继日志记录也是相同的。</p>
<p>因为如果两个日志的两条日志记录有相同的索引和任期证明他们此处及之前的日志记录都和Leader对应索引及之前的日志记录相同。</p>
<h3 id="选举部分"><a href="#选举部分" class="headerlink" title="选举部分"></a>选举部分</h3><ul>
<li><p>选举时选举出来的Leader必须是拥有所有已提交的日志</p>
</li>
<li><p>选举时，给Candidate投票的前提是：</p>
<p>• Candidate最后一个日志的term比自己最后一个日志的term大。（如果别人最后一个日志的term比自己的还大，证明别人最  </p>
<p>   后收到的消息的Leader比自己最后收到消息的Leader新，而新Leader比老Leader更全的已提交日志，复制给发送端的已提</p>
<p>   交日志比自己的更全，自己就要给它投票）</p>
<p>• 如果Candidate最后一个日志的term和自己的相同，但是其索引比自己的大。（最后一个日志的term相同说明都是由一个</p>
<p>  Leader复制的日志，而别人的日志长度更长说明别人别人之前收到Leader的日志更新，其比自己更有可能拥有所有已提交</p>
<p>  日志)</p>
</li>
</ul>
<blockquote>
<p>细节一</p>
</blockquote>
<p>在节点处理RPC请求逻辑中，本来是为了快速过滤掉不符合的选举请求，将所有不满足条件的请求直接返回flase。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Candidate的term比自己小，或者自己已经投过票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt;= rf.currentTerm &#123;</span><br><span class="line">    reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.如果Candidate的日志最后的term比自己的小</span></span><br><span class="line"><span class="comment">//2.最后日志的term相等，但是Candidate最后日志的index比自己的小</span></span><br><span class="line"><span class="comment">//拒绝投票</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(args.LastLogTerm &lt; rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term || (args.LastLogTerm ==  rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &lt; <span class="built_in">len</span>(rf.logs)))&#123;   </span><br><span class="line">    reply.VoteGranted = <span class="literal">false</span>   </span><br><span class="line">    reply.Term = args.Term</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.status = Follower</span><br><span class="line">rf.overtime = time.Duration(<span class="number">150</span>+rand.Intn(<span class="number">200</span>)) * time.Millisecond</span><br><span class="line">rf.timer.Reset(rf.overtime)</span><br></pre></td></tr></table></figure>

<p>在一般情况下可以正确运行，但是当大部分节点crash掉，然后重连后，会出现特例情况。</p>
<p>比如：</p>
<p>在重新选举时，失联节点会更新term但因为日志不满足条件而不能成为Leader，但是此时未失联节点的term比失联后重新选举的小，未crash节点也无法成为Leader。此时除非未crash节点的两次选举之间没有其他节点竞选，可能会因term更新选举上。</p>
<p>解决办法：</p>
<p>将节点currentTerm的更新放到任期判断逻辑前面，这样做有两个好处：</p>
<p>1.任期判断没有返回就说明其他节点的term已经比自身的term大，此时也应该即时的修改自身的term。</p>
<p>2.即使发生上面那种情况解决，未crash节点也能在因日志不满足返回前将自身的term即时更新为crash过的节点，这样等到自  	己选举时可以成功竞选上，以免浪费大量时间在选举上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Candidate的term比自己小，或者自己已经投过票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt;= rf.currentTerm &#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.status = Follower</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.如果Candidate的日志最后的term比自己的小</span></span><br><span class="line"><span class="comment">//2.最后日志的term相等，但是Candidate最后日志的index比自己的小</span></span><br><span class="line"><span class="comment">//拒绝投票</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.logs) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(args.LastLogTerm &lt; rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term || (args.LastLogTerm ==  rf.logs[<span class="built_in">len</span>(rf.logs)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &lt; <span class="built_in">len</span>(rf.logs)))&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="心跳部分"><a href="#心跳部分" class="headerlink" title="心跳部分"></a>心跳部分</h3><blockquote>
<p>接收端任期更新细节</p>
</blockquote>
<p>心跳部分也要注意和选举部分细节一样的地方，而且还需额外更新当前节点的超时选举</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Leader的term比自己的还小</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.status = Follower</span><br><span class="line">rf.overtime = time.Duration(<span class="number">150</span>+rand.Intn(<span class="number">200</span>)) * time.Millisecond</span><br><span class="line">rf.timer.Reset(rf.overtime)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不满足日志赋值</span></span><br><span class="line"><span class="comment">//1.自己logs在preLogIndex处没有日志</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex != <span class="number">0</span> &amp;&amp; args.PreLogIndex &gt; <span class="built_in">len</span>(rf.logs)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.自己与Leader在preLogIndex处的日志不相同</span></span><br><span class="line"><span class="comment">//TODO 优化reply.NextIndex</span></span><br><span class="line"><span class="keyword">if</span> args.PreLogIndex != <span class="number">0</span> &amp;&amp; rf.logs[args.PreLogIndex - <span class="number">1</span>].Term != args.PreLogTerm&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果因为某种情况没有了Leader，而Follower的大部分日志都不相同，这时就需要大量的心跳来测试出PreLogIndex的大概位置。此时某个Follower选举上，nextIndex[i]都初始化为自己logs的长度，需要不断发送心跳来试每个Follower正确的PreLogIndex。而如果不把更新超时时间放在日志冲突判断前，此时若发生日志冲突但不会更新选举超时，而这样会导致在大量心跳测试PreLogIndex时Follower触发超时选举，term会增加，会使Leader变回Follower。但因为日志原因，最后原Leader会又变回Leader，但是nextIndex[i]有初始化为logs的长度。又发生上面情况，依次往复，一直不能完成日志复制。</p>
<p>而这样做也符合要求，Follower接收到比自己term大的Leader的心跳，就会更新超时选举，即使日志不能匹配，也只是返回自己期望的下一个PreLogIndex。</p>
<blockquote>
<p>发送端过滤之前心跳</p>
</blockquote>
<p>在2A处心跳只是用来更新超时选举和更正Leader任期，只需过滤掉之前任期的心跳，即使是当前任期之前发送的其他心跳，也没有必要过滤。</p>
<p>但是添加了日志复制，如果不过滤当前任期之前的心跳，可能会导致下面使nextIndex回退，一直匹配不上期望的nextIndex。</p>
<p>选举的话，每一次选举就会让term增加，只需判断rf.currentTerm和args.term就可以过滤之前的选举。而过滤当前term之前发送的心跳就需要用rf.nextIndex[followerId] 和 args.PreLogIndex比较，因为每一次心跳都会导致nextIndex向前匹配，而PreLogIndex值和nextIndex一样，如果它两不相等就是之前发送的心跳。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term || rf.status != Leader || rf.nextIndex[followerId] != args.PreLogIndex&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !reply.Success &#123;</span><br><span class="line">    <span class="comment">//日志复制失败</span></span><br><span class="line">    <span class="keyword">if</span>  rf.currentTerm == reply.Term&#123;</span><br><span class="line">        <span class="comment">//如果前面不加rf.nextIndex[followerId] != args.PreLogIndex判断就可能发生下面情况：</span></span><br><span class="line">        <span class="comment">//几次心跳已经让nextIndex向前匹配期望nextIndex，但是接收到当前term的之前发送的心跳，使得nextIndex又回退</span></span><br><span class="line">        rf.nextIndex[followerId] = reply.NextIndex       </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出现网络分区</span></span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="响应消息给状态机"><a href="#响应消息给状态机" class="headerlink" title="响应消息给状态机"></a>响应消息给状态机</h3><p>在SendAppenEntires和AppenEntires中当满足一些条件时生成响应消息通过channel给状态机，而方法中开始就用Lock和defer UnLock，但是如果channel阻塞住，就会一直不释放锁，所以需要将响应消息放到锁区间外面。</p>
<h2 id="Lab2C持久化"><a href="#Lab2C持久化" class="headerlink" title="Lab2C持久化"></a>Lab2C持久化</h2><p>持久化主要持久化以下属性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rf.currentTerm <span class="comment">//持久化该属性是为了在选举或心跳时，知道自己的term来处理RPC携带的term</span></span><br><span class="line">rf.votedFor	<span class="comment">//持久化该属性是为了避免重启后，自己之前给term中某个节点投过票，不持久化的话，会再给其他节点投票，发生				半票等情况</span></span><br><span class="line">rf.logs </span><br><span class="line">rf.lastIncludeIndex <span class="comment">//持久化该属性是为了知道自己从哪个索引进行的日志快照，如果不持久化的话，在日志快照部分会有许多					下标问题</span></span><br><span class="line">rf.lastIncludeTerm <span class="comment">//持久化该属性是为了在加了日志快照模块后，正确处理心跳</span></span><br></pre></td></tr></table></figure>

<p>其他属性都可以通过再次选举得到，比如commitIndex，raft通过持久化恢复后可以通过不断的心跳得到原来的commitIndex。</p>
<h2 id="Lab2D日志快照"><a href="#Lab2D日志快照" class="headerlink" title="Lab2D日志快照"></a>Lab2D日志快照</h2><p>日志快照主要是引入了lastIncludeIndex和lasstIncludeTerm两个属性，但是需要将原来代码关于下标部分全部进行修改，否则会出现下标问题，如数组越界，在ticker函数情况考虑不全没有发送任何RPC导致一直选举等问题。</p>
<h1 id="KV数据库"><a href="#KV数据库" class="headerlink" title="KV数据库"></a>KV数据库</h1><h2 id="Lab3A-client和server"><a href="#Lab3A-client和server" class="headerlink" title="Lab3A client和server"></a>Lab3A client和server</h2><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>一开始，Client 并不知道 Leader Server 是哪台 Server。Client 可向随机一台 Server 发送 RPC 请求。假如请求的 Server 不是当前的 Leader Server，或者由于网络中断、Server Crash 等原因，无法与 Server 取得联系，则无限地尝试更换 Server 重新发送请求，直到请求成功被处理。在得知 Leader Server 后，Client 保存 Leader 的 id，避免下次发起请求时又需要随机地选择一台 Server 多次尝试。</p>
<p>Client 发送的请求 Server 成功接收，Server 也将请求中的 command 成功在 Raft 层达成共识并应用至状态机，然而在回复 Client 时出现了问题，RPC 回复丢失。这样就有可能导致一次请求多次重复提交的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">	servers []*labrpc.ClientEnd</span><br><span class="line">	<span class="comment">// You will have to modify this struct.</span></span><br><span class="line">	seqId <span class="type">int64</span></span><br><span class="line">	leaderId <span class="type">int</span></span><br><span class="line">	clientId <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server在接收到 Client 的请求后，通过调用 <code>raft.Start()</code> 将请求包含的 command 传递到 Raft 层，达成共识。</p>
<ul>
<li>Raft 层达成共识后，通过 applyCh 通知 Server 该 command 已达成共识，然后Server返回给Client。</li>
<li>如果当前 Server 不为 Leader，则向 Client 返回错误，Client 在收到回复后重新尝试向另一台 Server 发起请求。</li>
</ul>
<p>但如果有多个 Client 并行地调用Server，因为在raft层不知道放入applyCh命令的顺序，Server层也就不能保证从 applyCh 每次取出的结果与期望的Client对应。为了解决这个问题，需要细化给Client返回的结果是从什么中获取，这里想的是建立一个commandIndex和新建channel的映射。当命令进入Raft层时就会返回给Server对应的CommandIndex，因为Raft的Start方法是同步方法，每个CommandIndex都不同，在Server的方法中就能用CommandIndex来区分每一个Client的调用，Raft达成共识后Server从响应结果就知道是哪个CommandIndex对应的结果，然后从映射中获取到对应的channel来响应对应的Client。</p>
<p>如果 Raft 层长时间无法完成共识 (由于网络分区等原因)，不要让 Server 一直阻塞。及时向 Client 返回 Timeout 错误，使其重新选择另一台 Server 重试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	me      <span class="type">int</span></span><br><span class="line">	rf      *raft.Raft</span><br><span class="line">	applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">	dead    <span class="type">int32</span> <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">	maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	kvPersist <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> <span class="comment">//持久化key/value对</span></span><br><span class="line">	waitChMap <span class="keyword">map</span>[<span class="type">int</span>] <span class="keyword">chan</span> Op <span class="comment">//上面解释了</span></span><br><span class="line">	maxSeq <span class="keyword">map</span>[<span class="type">int64</span>] <span class="type">int64</span> <span class="comment">//fault-tolerant最后一个点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fault-tolerant"><a href="#fault-tolerant" class="headerlink" title="fault-tolerant"></a>fault-tolerant</h3><p>可能出现的fault：</p>
<ul>
<li>Client给Server发送RPC，因某些原因Server未收到。<ul>
<li>让Client慢慢给其他Server发送RPC重试</li>
</ul>
</li>
<li>Server调用Raft的Start方法添加日志失败<ul>
<li>不断重试调用Start方法</li>
</ul>
</li>
<li>Raft达成共识了，但是给Server返回时出现问题<ul>
<li><strong>先将封装的结果返回，再增加节点的lastApplied</strong>，这样如果给Server返回失败，在以后某个时刻节点从lastApplied也知道应该将该结果返回</li>
</ul>
</li>
<li>Server收到Raft的结果，但是并没有来得及执行命令，导致命令多次被Raft共识。<ul>
<li>？Raft对SeqId也进行去重</li>
</ul>
</li>
<li>Server执行了命令，但是没有来得及返回给Client，Client会不断重试导致命令被多次执行。<ul>
<li>问题是一个命令会被多次执行，Raft只管日志共识，并不用管日志是否重复被共识，所以需要由Client和Server来保证。Client创建时建立一个属性SeqId，每当一个命令被Server执行就自增SeqId，Server建立一个ClientId和SeqId的映射，每次在Raft响应后通过maxSeq[ClientId]&lt;SeqId，如果不满足就证明该命令已被执行过，不再执行，直接返回给Client。（<strong>值的注意的是</strong>：判断和修改maxSeq[ClientId]的时机，需要<strong>等到Server收到Raft共识后的响应时才能才操作maxSeq</strong>。因为如果命令执行后，Leader又换为其他Server，Client也会转向变为Leader的Server发送命令，但此时该Server的maxSeq并没有更新，又触发Raft共识操作，相当于命令被执行了两次。而在Server接收到Raft共识后操作，会因为Raft共识后会给那些日志复制成功的Server响应，而他们的maxSeq也被修改了，并且新的Leader只会从他们中选举出来）</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2024/03/11/note/%E9%A1%B9%E7%9B%AE/mit824/" data-id="cltu174th001p48nu34wva9vn" data-title="mit6.824.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/03/11/note/%E6%A1%86%E6%9E%B6/spring/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring.md
        
      </div>
    </a>
  
  
    <a href="/2024/03/11/note/%E9%A1%B9%E7%9B%AE/%E7%82%B9%E8%AF%84/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">点评.md</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/juc/">juc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E9%A1%B9%E7%9B%AE/">项目</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/11/note/jvm/jvm/">jvm.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/AQS/">AQS.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/Future/">Future.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/ConcurrentHashMap/">ConcurrentHashMap.md</a>
          </li>
        
          <li>
            <a href="/2024/03/11/note/juc/Executor/">Executor.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 1Stack1<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>